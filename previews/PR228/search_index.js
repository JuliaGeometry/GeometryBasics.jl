var documenterSearchIndex = {"docs":
[{"location":"static_array_types/#Point,-Vec-and-Mat","page":"Point, Vec and Mat","title":"Point, Vec and Mat","text":"","category":"section"},{"location":"static_array_types/","page":"Point, Vec and Mat","title":"Point, Vec and Mat","text":"GeometryBasics defines its own set of (small) Static Vectors and Matrices:","category":"page"},{"location":"static_array_types/","page":"Point, Vec and Mat","title":"Point, Vec and Mat","text":"Point{N,T} <: StaticVector{N,T} <: AbstractVector{T}\nVec{N,T} <: StaticVector{N,T} <: AbstractVector{T}\nMat{Row, Column, T, L} <: AbstractMatrix{T}","category":"page"},{"location":"static_array_types/","page":"Point, Vec and Mat","title":"Point, Vec and Mat","text":"These types are used throughout GeometryBasics to speed up calculations similar to how StaticArrays.jl does.","category":"page"},{"location":"static_array_types/#Aliases","page":"Point, Vec and Mat","title":"Aliases","text":"","category":"section"},{"location":"static_array_types/","page":"Point, Vec and Mat","title":"Point, Vec and Mat","text":"GeometryBasics exports common aliases for Point, Vec, Mat and Rect:","category":"page"},{"location":"static_array_types/#Vec","page":"Point, Vec and Mat","title":"Vec","text":"","category":"section"},{"location":"static_array_types/","page":"Point, Vec and Mat","title":"Point, Vec and Mat","text":" T(eltype) Float64 Float32 Int UInt\nN(dim) Vec{N,T} Vecd{N} Vecf{N} Veci{N} Vecui{N}\n2 Vec2{T} Vec2d Vec2f Vec2i Vec2ui\n3 Vec3{T} Vec3d Vec3f Vec3i Vec3ui","category":"page"},{"location":"static_array_types/#Point","page":"Point, Vec and Mat","title":"Point","text":"","category":"section"},{"location":"static_array_types/","page":"Point, Vec and Mat","title":"Point, Vec and Mat","text":" T(eltype) Float64 Float32 Int UInt\nN(dim) Point{N,T} Pointd{N} Pointf{N} Pointi{N} Pointui{N}\n2 Point2{T} Point2d Point2f Point2i Point2ui\n3 Point3{T} Point3d Point3f Point3i Point3ui","category":"page"},{"location":"static_array_types/#Mat","page":"Point, Vec and Mat","title":"Mat","text":"","category":"section"},{"location":"static_array_types/","page":"Point, Vec and Mat","title":"Point, Vec and Mat","text":" T(eltype) Float64 Float32 Int UInt\nN(dim) Mat{N,T} Matd{N} Matf{N} Mati{N} Matui{N}\n2 Mat2{T} Mat2d Mat2f Mat2i Mat2ui\n3 Mat3{T} Mat3d Mat3f Mat3i Mat3ui","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Exports","page":"API Reference","title":"Exports","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [GeometryBasics]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api/#GeometryBasics.AbstractFace","page":"API Reference","title":"GeometryBasics.AbstractFace","text":"AbstractFace{N_indices, T} <: StaticVector{N_indices, T}\n\nParent type for all face types. The standard face type is typically a  GLTriangleFace = NgonFace{3, GLIndex}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.AbstractGeometry","page":"API Reference","title":"GeometryBasics.AbstractGeometry","text":"abstract type AbstractGeometry{Dimension, T<:Number}\n\nBase type for geometry types like GeometryPrimites and Polytopes.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.AbstractMesh","page":"API Reference","title":"GeometryBasics.AbstractMesh","text":"AbstractMesh\n\nAn abstract mesh is a collection of Polytope elements (Simplices / Ngons). The  connections are defined via faces(mesh) and the coordinates of the elements are  returned by coordinates(mesh).\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Circle","page":"API Reference","title":"GeometryBasics.Circle","text":"Circle{T}\n\nAn alias for a HyperSphere of dimension 2. (i.e. HyperSphere{2, T})\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Cylinder","page":"API Reference","title":"GeometryBasics.Cylinder","text":"Cylinder{T}(origin::Point3, extremity::Point3, radius)\n\nA Cylinder is a 3D primitive defined by an origin, an extremity (end point) and a radius.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.FaceView","page":"API Reference","title":"GeometryBasics.FaceView","text":"FaceView(data, faces)\n\nA FaceView is an alternative to passing a vertex attribute directly to a mesh.  It bundles data with a new set of faces which may index that data differently from the faces defined in a mesh. This can be useful to avoid duplication in data.\n\nFor example, data can be defined per face by giving each face just one (repeated) index:\n\nper_face_normals = FaceView(\n    normals,                 # one per face\n    FT.(eachindex(normals))  # with FT = facetype(mesh)\n)\n\nIf you need a mesh with strictly per-vertex data, e.g. for rendering, you can use  expand_faceviews(mesh) to convert every vertex attribute to be per-vertex. This will duplicate data and reorder faces as needed.\n\nYou can get the data of a FaceView with values(faceview) and the faces with faces(faceview).\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.HyperRectangle","page":"API Reference","title":"GeometryBasics.HyperRectangle","text":"HyperRectangle{N, T}\n\nA HyperRectangle is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the origin and widths fields, whose indices correspond to each of the N axes.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.HyperSphere","page":"API Reference","title":"GeometryBasics.HyperSphere","text":"HyperSphere{N, T}\n\nA HyperSphere is a generalization of a sphere into N-dimensions. A center and radius, r, must be specified.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.LineString","page":"API Reference","title":"GeometryBasics.LineString","text":"LineString(points::AbstractVector{<:Point})\n\nA LineString is a collection of points connected by line segments.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Mat","page":"API Reference","title":"GeometryBasics.Mat","text":"Mat{R, C, T[, L]}(args::Union{UniformScaling, Tuple, AbstractMatrix})\nMat{R, C}(args::Union{Tuple, AbstractMatrix})\nMat{C}(args::Tuple)\n\nConstructs a static Matrix from the given inputs. Can also take multiple numeric args. If only one size is given the matrix is assumed to be square.\n\nAliases\n\n T Float64 Float32 Int UInt\nN Mat{N,T} Matd{N} Matf{N} Mati{N} Matui{N}\n2 Mat2{T} Mat2d Mat2f Mat2i Mat2ui\n3 Mat3{T} Mat3d Mat3f Mat3i Mat3ui\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Mesh","page":"API Reference","title":"GeometryBasics.Mesh","text":"Mesh{PositionDim, PositionType, FaceType, VertexAttributeNames, VertexAttributeTypes, FaceVectorType} <: AbstractMesh{PositionDim, PositionType} <: AbstractGeometry{PositionDim, PositionType}\n\nThe type of a concrete mesh. The associated struct contains 3 fields:\n\nstruct Mesh{...}\n    vertex_attributes::NamedTuple{VertexAttributeNames, VertexAttributeTypes}\n    faces::FaceVectorType\n    views::Vector{UnitRange{Int}}\nend\n\nA vertex typically carries multiple distinct pieces of data, e.g. a position,  a normal, a texture coordinate, etc. We call those pieces of data vertex  attributes. The vertex_attributes field contains the name and a collection  <: AbstractVector or <: FaceView for each attribute. The n-th element of that collection is the value of the corresponding attribute for the n-th vertex.\n\n#                   vertex       1        2        3\nvertex_attributes[:position] = [pos1,    pos2,    pos3,    ...]\nvertex_attributes[:normal]   = [normal1, normal2, normal3, ...]\n...\n\nA NamedTuple is used here to allow different meshes to carry different vertex  attributes while also keeping things type stable. The constructor enforces a  few restrictions:\n\nThe first attribute must be named position and must have a Point{PositionDim, PositionType} eltype.\nEach vertex attribute must refer to the same number of vertices. (All vertex attributes defined by \n\nAbstractVector must match in length. For FaceViews, the number of faces needs to match.)\n\nSee also: vertex_attributes, coordinates, normals,  texturecoordinates, decompose, FaceView,  expand_faceviews\n\nThe faces field is a collection <: AbstractVector{FaceType} containing faces  that describe how vertices are connected. Typically these are (GL)TriangleFaces or QuadFaces, but they can be any collection of vertex indices <: AbstractFace.\n\nSee also: faces, decompose\n\nThe views field can be used to separate the mesh into mutliple submeshes. Each  submesh is described by a \"view\" into the faces vector, i.e. submesh n uses  mesh.faces[mesh.views[n]]. A Mesh can be constructed without views, which  results in an empty views vector. \n\nSee also: merge, split_mesh\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Mesh-Tuple{AbstractVector{<:AbstractFace}}","page":"API Reference","title":"GeometryBasics.Mesh","text":"Mesh(faces[; views, attributes...])\nMesh(positions, faces[; views])\nMesh(positions, faces::AbstractVector{<: Integer}[; facetype = TriangleFace, skip = 1])\nMesh(; attributes...)\n\nConstructs a mesh from the given arguments.\n\nIf positions are given explicitly, they are merged with other vertex attributes  under the name position. Otherwise they must be part of attributes. If faces are not given attributes.position must be a FaceView.\n\nAny other vertex attribute can be either an AbstractVector or a FaceView  thereof. Every vertex attribute that is an AbstractVector must be sufficiently large to be indexable by mesh.faces. Every vertex attribute that is a FaceView must contain similar faces to mesh.faces, i.e. contain the same number of faces and have faces of matching length.\n\nviews can be defined optionally to implicitly split the mesh into multi  sub-meshes. This is done by providing ranges for indexing faces which correspond to the sub-meshes. By default this is left empty.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.MetaMesh-Tuple{AbstractMesh}","page":"API Reference","title":"GeometryBasics.MetaMesh","text":"MetaMesh(mesh; metadata...)\nMetaMesh(positions, faces; metadata...)\n\nConstructs a MetaMesh either from another mesh or by constructing another mesh with the given positions and faces. Any keyword arguments given will be stored in the meta field in MetaMesh.\n\nThis struct is meant to be used for storage of non-vertex data. Any vertex  related data should be stored as a vertex attribute in Mesh. One example of such  data is material data, which is defined per view in mesh.views, i.e. per submesh.\n\nThe metadata added to the MetaMesh can be manipulated with Dict-like operations  (getindex, setindex!, get, delete, keys, etc). Vertex attributes can be accessed  via fields and the same getters as mesh. The mesh itself can be retrieved with  Mesh(metamesh).\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.MultiPoint","page":"API Reference","title":"GeometryBasics.MultiPoint","text":"MultiPoint(points::AbstractVector{AbstractPoint})\n\nA collection of points\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.MultiPolygon","page":"API Reference","title":"GeometryBasics.MultiPolygon","text":"MultiPolygon(polygons::AbstractPolygon)\n\nA collection of polygons\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.NgonFace","page":"API Reference","title":"GeometryBasics.NgonFace","text":"NgonFace{N, T}\n\nA planar face connecting N vertices. Shorthands include:\n\nLineFace{T} = NgonFace{2,T}\nTriangleFace{T} = NgonFace{3,T}\nQuadFace{T} = NgonFace{4,T}\nGLTriangleFace = TriangleFace{GLIndex}\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.OffsetInteger","page":"API Reference","title":"GeometryBasics.OffsetInteger","text":"OffsetInteger{O, T}\n\nOffsetInteger type mainly for indexing.\n\nO - The offset relative to Julia arrays. This helps reduce copying when\n\ncommunicating with 0-indexed systems such as OpenGL.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Point","page":"API Reference","title":"GeometryBasics.Point","text":"Point{N, T}(args...)\nPoint{N, T}(args::Union{AbstractVector, Tuple, NTuple, StaticVector})\n\nConstructs a Point of length N from the given arguments. \n\nNote that Point and Vec don't follow strict mathematical definitions. Instead  we allow them to be used interchangeably.\n\nAliases\n\n T Float64 Float32 Int UInt\nN Point{N,T} Pointd{N} Pointf{N} Pointi{N} Pointui{N}\n2 Point2{T} Point2d Point2f Point2i Point2ui\n3 Point3{T} Point3d Point3f Point3i Point3ui\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Polygon","page":"API Reference","title":"GeometryBasics.Polygon","text":"Polygon(exterior::AbstractVector{<:Point})\nPolygon(exterior::AbstractVector{<:Point}, interiors::Vector{<:AbstractVector{<:Point}})\n\nConstructs a polygon from a set of exterior points. If interiors are given, each of them cuts away from the Polygon.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Polytope","page":"API Reference","title":"GeometryBasics.Polytope","text":"Polytope{Dim, T} <: AbstractGeometry{Dim, T}\n\nA Polytope is the generalization of a Polygon to higher dimensions, i.e. a  geometric object consisting of flat faces.\n\nA Polygon and Ngon are both 2D Polytopes. A Simplex is the simplest Polytope in arbitrary dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Polytope-Union{Tuple{IT}, Tuple{T}, Tuple{Dim}, Tuple{N}, Tuple{Type{Point{Dim, T}}, Type{<:GeometryBasics.AbstractNgonFace{N, IT}}}} where {N, Dim, T, IT}","page":"API Reference","title":"GeometryBasics.Polytope","text":"Polytope(::Type{<: Point}, ::Type{<: AbstractNgonFace})\n\nThe Ngon Polytope element type when indexing an array of points with a SimplexFace\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Polytope-Union{Tuple{T}, Tuple{Dim}, Tuple{N}, Tuple{Type{Point{Dim, T}}, Type{<:GeometryBasics.AbstractSimplexFace{N}}}} where {N, Dim, T}","page":"API Reference","title":"GeometryBasics.Polytope","text":"Polytope(::Type{Point{Dim,T}}, ::Type{<:AbstractSimplexFace{N}})\n\nThe Simplex Polytope element type when indexing an array of points with a SimplexFace\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Polytope-Union{Tuple{T}, Tuple{NDim}, Tuple{N}, Tuple{Type{<:NSimplex{N}}, Type{Point{NDim, T}}}} where {N, NDim, T}","page":"API Reference","title":"GeometryBasics.Polytope","text":"Polytope(::Type{<:NSimplex{N}}, P::Type{Point{NDim,T}})\n\nThe fully concrete Simplex type, when constructed from a point type!\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Polytope-Union{Tuple{_T}, Tuple{_D}, Tuple{T}, Tuple{NDim}, Tuple{N}, Tuple{Type{<:GeometryBasics.Ngon{_D, _T, N}}, Type{Point{NDim, T}}}} where {N, NDim, T, _D, _T}","page":"API Reference","title":"GeometryBasics.Polytope","text":"Polytope(::Type{<: Ngon}, P::Type{<: Point})\n\nThe fully concrete Ngon type, when constructed from a point type!\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Pyramid","page":"API Reference","title":"GeometryBasics.Pyramid","text":"Pyramid(middle::Point3, length::Real, width::Real)\n\nA Pyramid is an axis-aligned primitive where the tip of the Pyramid extends by  length from middle in z direction and the square base extends by width in ±x and ±y direction from middle. \n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect","page":"API Reference","title":"GeometryBasics.Rect","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect-Union{NTuple{N, Number}, Tuple{N}} where N","page":"API Reference","title":"GeometryBasics.Rect","text":"Rect(vals::Number...)\n\nRect(vals::Number...)\n\nRect constructor for individually specified intervals. e.g. Rect(0,0,1,2) has origin == Vec(0,0) and width == Vec(1,2)\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Rect-Union{Tuple{AbstractArray{PT}}, Tuple{PT}, Tuple{T1}, Tuple{N1}} where {N1, T1, PT<:Point}","page":"API Reference","title":"GeometryBasics.Rect","text":"Rect(points::AbstractArray{<: Point})\n\nConstruct a bounding box countaining all the given points.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Rect-Union{Tuple{GeometryPrimitive{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"API Reference","title":"GeometryBasics.Rect","text":"Rect(primitive::GeometryPrimitive)\n\nConstruct a bounding box for the given primitive.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Rect2","page":"API Reference","title":"GeometryBasics.Rect2","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect2d","page":"API Reference","title":"GeometryBasics.Rect2d","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect2f","page":"API Reference","title":"GeometryBasics.Rect2f","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect2i","page":"API Reference","title":"GeometryBasics.Rect2i","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect3","page":"API Reference","title":"GeometryBasics.Rect3","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect3d","page":"API Reference","title":"GeometryBasics.Rect3d","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect3f","page":"API Reference","title":"GeometryBasics.Rect3f","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect3i","page":"API Reference","title":"GeometryBasics.Rect3i","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rectd","page":"API Reference","title":"GeometryBasics.Rectd","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rectf","page":"API Reference","title":"GeometryBasics.Rectf","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Recti","page":"API Reference","title":"GeometryBasics.Recti","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Simplex","page":"API Reference","title":"GeometryBasics.Simplex","text":"Simplex{D, T<:Real, N}(points::NTuple{N, Point{D, T}})\n\nA Simplex is a generalization of an N-dimensional tetrahedra and can be thought of as a minimal convex set containing the specified points.\n\nA 0-simplex is a point.\nA 1-simplex is a line segment.\nA 2-simplex is a triangle.\nA 3-simplex is a tetrahedron.\n\nNote that this datatype is offset by one compared to the traditional mathematical terminology. So a one-simplex is represented as Simplex{2,T}. This is for a simpler implementation.\n\nIt applies to infinite dimensions. The structure of this type is designed to allow embedding in higher-order spaces by parameterizing on T.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Sphere","page":"API Reference","title":"GeometryBasics.Sphere","text":"Sphere{T}\n\nAn alias for a HyperSphere of dimension 3. (i.e. HyperSphere{3, T})\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Tessellation","page":"API Reference","title":"GeometryBasics.Tessellation","text":"Tessellation(primitive, nvertices)\n\nWhen generating a mesh from an abstract geometry, we can typically generate it at different levels of detail, i.e. with different amounts of vertices. The  Tessellation wrapper allows you to specify this level of detail. When generating a mesh from a tessellated geometry, the added information will be passed to  coordinates, faces, etc.\n\nsphere = Sphere(Point3f(0), 1)\nm1 = mesh(sphere) # uses a default value for tessellation\nm2 = mesh(Tessellation(sphere, 64)) # uses 64 for tessellation\nlength(coordinates(m1)) != length(coordinates(m2))\n\nFor grid based tessellation, you can also use a tuple:\n\nrect = Rect2(0, 0, 1, 1)\nTessellation(rect, (5, 5))\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.TupleView","page":"API Reference","title":"GeometryBasics.TupleView","text":"TupleView{T, N, Skip, A}\n\nTupleView, groups elements of an array as tuples. N is the dimension of the tuple, M tells how many elements to skip to the next tuple. By default TupleView{N} defaults to skip N items.\n\na few examples:\n\n\nx = [1, 2, 3, 4, 5, 6]\nTupleView{2, 1}(x):\n> [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\n\nTupleView{2}(x):\n> [(1, 2), (3, 4), (5, 6)]\n\nTupleView{2, 3}(x):\n> [(1, 2), (4, 5)]\n\nTupleView{3, 1}(x):\n> [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]\n\nTupleView can be used together with reinterpret:\n\nx = [1, 2, 3, 4]\ny = reinterpret(Point{2, Int}, TupleView{2, 1}(x))\n> [Point(1, 2), Point(2, 3), Point(3, 4)]\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Vec","page":"API Reference","title":"GeometryBasics.Vec","text":"Vec{N, T}(args...)\nVec{N, T}(args::Union{AbstractVector, Tuple, NTuple, StaticVector})\n\nConstructs a Vec of length N from the given arguments. \n\nNote that Point and Vec don't follow strict mathematical definitions. Instead  we allow them to be used interchangeably.\n\nAliases\n\n T Float64 Float32 Int UInt\nN Vec{N,T} Vecd{N} Vecf{N} Veci{N} Vecui{N}\n2 Vec2{T} Vec2d Vec2f Vec2i Vec2ui\n3 Vec3{T} Vec3d Vec3f Vec3i Vec3ui\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.area-Union{Tuple{AbstractArray{Point2{T}, 1}}, Tuple{T}} where T","page":"API Reference","title":"GeometryBasics.area","text":"area(contour::AbstractVector{Point}})\n\nCalculate the area of a polygon.\n\nFor 2D points, the oriented area is returned (negative when the points are oriented clockwise).\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.area-Union{Tuple{FT}, Tuple{VT}, Tuple{AbstractArray{Point3{VT}, 1}, AbstractArray{TriangleFace{FT}, 1}}} where {VT, FT}","page":"API Reference","title":"GeometryBasics.area","text":"area(vertices::AbstractVector{Point{3}}, faces::AbstractVector{TriangleFace})\n\nCalculate the area of all triangles.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.area-Union{Tuple{FT}, Tuple{VT}, Tuple{AbstractVector{<:Point3{VT}}, TriangleFace{FT}}} where {VT, FT}","page":"API Reference","title":"GeometryBasics.area","text":"area(vertices::AbstractVector{Point{3}}, face::TriangleFace)\n\nCalculate the area of one triangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.connect-Union{Tuple{Point}, Tuple{AbstractVector{Point}, Type{<:Polytope}}, Tuple{AbstractVector{Point}, Type{<:Polytope}, Int64}} where Point<:Point","page":"API Reference","title":"GeometryBasics.connect","text":"connect(points::AbstractVector{<: Point}, P::Type{<: Polytope{N}}, skip::Int = N)\n\nCreates a view that connects a number of points to a Polytope P. Between each polytope, skip elements are skipped untill the next starts. Example: ```julia x = connect(Point[(1, 2), (3, 4), (5, 6), (7, 8)], Line, 2) x == [Line(Point(1, 2), Point(3, 4)), Line(Point(5, 6), Point(7, 8))]\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.convert_simplex-Union{Tuple{N}, Tuple{T}, Tuple{Type{LineFace{T}}, NgonFace{N}}} where {T, N}","page":"API Reference","title":"GeometryBasics.convert_simplex","text":"convert_simplex(::Type{Face{2}}, f::Face{N})\n\nExtract all line segments in a Face.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.convert_simplex-Union{Tuple{N}, Tuple{T}, Tuple{Type{TriangleFace{T}}, Union{NgonFace{N}, SimplexFace{N}}}} where {T, N}","page":"API Reference","title":"GeometryBasics.convert_simplex","text":"convert_simplex(::Type{Face{3}}, f::Face{N})\n\nTriangulate an N-Face into a tuple of triangular faces.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.convert_simplex-Union{Tuple{T}, Tuple{Type{T}, T}} where T","page":"API Reference","title":"GeometryBasics.convert_simplex","text":"convert_simplex(::Type{TargetType}, x)\n\nUsed to convert one object into another in decompose(::Type{TargetType}, xs).\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.coordinates-Tuple{AbstractVector{<:Point}}","page":"API Reference","title":"GeometryBasics.coordinates","text":"coordinates(geometry)\n\nReturns the positions/coordinates of a geometry. \n\nThis is allowed to return lazy iterators. Use decompose(ConcretePointType, geometry)  to get a Vector{ConcretePointType} with ConcretePointType being something like Point3f.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.decompose-Union{Tuple{F}, Tuple{Type{F}, AbstractGeometry}} where F<:AbstractFace","page":"API Reference","title":"GeometryBasics.decompose","text":"decompose(::Type{TargetType}, primitive)\ndecompose(::Type{TargetType}, data::AbstractVector)\n\nDependent on the given type, extracts data from the primtive and converts its  eltype to TargetType.\n\nPossible TargetTypes:\n\n<: Point extracts and converts positions (calling coordinates())\n<: AbstractFace extracts and converts faces (calling faces())\n<: Normal{<: Vec} extracts and converts normals, potentially generating them (calling normals())\n<: UV{<: Vec} extracts and converts 2D texture coordinates, potentially generating them (calling texturecoordinates())\n<: UVW{<: Vec} extracts and converts 3D texture coordinates, potentially generating them (calling texturecoordinates())\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.decompose-Union{Tuple{F}, Tuple{Type{F}, AbstractVector{<:Point}}} where F<:AbstractFace","page":"API Reference","title":"GeometryBasics.decompose","text":"decompose(facetype, contour::AbstractArray{<:Point})\n\nTriangulate a Polygon without hole.\n\nReturns a Vector{facetype} defining indexes into contour.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.expand_faceviews-Tuple{Mesh}","page":"API Reference","title":"GeometryBasics.expand_faceviews","text":"expand_faceviews(mesh::Mesh)\n\nReturns the given mesh if it contains no FaceViews. Otherwise, generates a new mesh that contains no FaceViews, reordering and duplicating vertex atttributes as necessary. If the mesh has views they will be adjusted as needed to produce the same submeshes.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.face_normals-Union{Tuple{T}, Tuple{AbstractVector{<:Point3{T}}, AbstractVector{<:AbstractFace}}} where T","page":"API Reference","title":"GeometryBasics.face_normals","text":"face_normals(positions::Vector{Point3{T}}, faces::Vector{<: NgonFace}[, target_type = Vec3{T}])\n\nCompute face normals from the given positions and faces and returns an appropriate FaceView.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.faces-Tuple{AbstractVector{<:AbstractFace}}","page":"API Reference","title":"GeometryBasics.faces","text":"faces(geometry)\n\nReturns the faces of a geometry. \n\nThis is allowed to return lazy iterators. Use decompose(ConcreteFaceType, geometry)  to get a Vector{ConcreteFaceType} with ConcreteFaceType being something like GLTriangleFace.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.normal_mesh-Tuple{AbstractVector{<:Point}, AbstractVector{<:AbstractFace}}","page":"API Reference","title":"GeometryBasics.normal_mesh","text":"uv_normal_mesh(primitive::GeometryPrimitive{N}[; pointtype = Point{N, Float32}, facetype = GLTriangleFace, uvtype = Vec2f, normaltype = Vec3f])\n\nCreates a triangle mesh with texture coordinates and normals from a given  primitive. The pointtype, facetype and uvtype and normaltype are set  by the correspondering keyword arguments. \n\nSee also: triangle_mesh, normal_mesh, uv_mesh, uv_normal_mesh\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.normal_mesh-Union{Tuple{AbstractGeometry{N}}, Tuple{N}} where N","page":"API Reference","title":"GeometryBasics.normal_mesh","text":"normal_mesh(primitive::GeometryPrimitive{N}[; pointtype = Point{N, Float32}, facetype = GLTriangleFace, normaltype = Vec3f])\n\nCreates a triangle mesh with normals from a given primitive. The pointtype, facetype and uvtype and normaltype are set  by the correspondering keyword arguments. \n\nSee also: triangle_mesh, normal_mesh, uv_mesh, uv_normal_mesh\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.normals","page":"API Reference","title":"GeometryBasics.normals","text":"normals(primitive)\n\nReturns the normals of a geometry. \n\nThis is allowed to return lazy iterators. Use decompose_normals(ConcreteVecType, geometry)  to get a Vector{ConcreteVecType} with ConcreteVecType being something like Vec3f.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryBasics.normals-Union{Tuple{F}, Tuple{T}, Tuple{AbstractArray{Point3{T}, 1}, AbstractVector{F}}} where {T, F<:NgonFace}","page":"API Reference","title":"GeometryBasics.normals","text":"normals(positions::Vector{Point3{T}}, faces::Vector{<: NgonFace}[; normaltype = Vec3{T}])\n\nCompute vertex normals from the given positions and faces.\n\nThis runs through all faces, computing a face normal each and adding it to every involved vertex. The direction of the face normal is based on winding direction  and assumed counter-clockwise faces. At the end the summed face normals are  normalized again to produce a vertex normal.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.self_intersections-Tuple{AbstractVector{<:Point}}","page":"API Reference","title":"GeometryBasics.self_intersections","text":"self_intersections(points::AbstractVector{<:Point})\n\nFinds all self intersections of polygon points\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.split_intersections-Tuple{AbstractVector{<:Point}}","page":"API Reference","title":"GeometryBasics.split_intersections","text":"split_intersections(points::AbstractVector{<: Point})\n\nSplits polygon points into it's self intersecting parts. Only 1 intersection is handled right now.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.texturecoordinates","page":"API Reference","title":"GeometryBasics.texturecoordinates","text":"texturecoordinates(primitive)\n\nReturns the texturecoordinates of a geometry. \n\nThis is allowed to return lazy iterators. Use decompose_uv(ConcreteVecType, geometry)  (or decompose_uvw) to get a Vector{ConcreteVecType} with ConcreteVecType being  something like Vec2f.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeometryBasics.triangle_mesh-Union{Tuple{Union{AbstractVector{<:Point{N}}, AbstractGeometry{N}}}, Tuple{N}} where N","page":"API Reference","title":"GeometryBasics.triangle_mesh","text":"triangle_mesh(primitive::GeometryPrimitive[; pointtype = Point, facetype = GLTriangleFace])\n\nCreates a simple triangle mesh from a given primitive with the given pointtype and facetype. \n\nSee also: triangle_mesh, normal_mesh, uv_mesh, uv_normal_mesh\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.uv_mesh-Union{Tuple{AbstractGeometry{N}}, Tuple{N}} where N","page":"API Reference","title":"GeometryBasics.uv_mesh","text":"uv_mesh(primitive::GeometryPrimitive{N}[; pointtype = Point{N, Float32}, facetype = GLTriangleFace, uvtype = Vec2f])\n\nCreates a triangle mesh with texture coordinates from a given primitive. The  pointtype, facetype and uvtype are set by the correspondering keyword arguments. \n\nSee also: triangle_mesh, normal_mesh, uv_mesh, uv_normal_mesh\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.uv_normal_mesh-Union{Tuple{AbstractGeometry{N}}, Tuple{N}} where N","page":"API Reference","title":"GeometryBasics.uv_normal_mesh","text":"uv_normal_mesh(primitive::GeometryPrimitive{N}[; pointtype = Point{N, Float32}, facetype = GLTriangleFace, uvtype = Vec2f, normaltype = Vec3f])\n\nCreates a triangle mesh with texture coordinates and normals from a given  primitive. The pointtype, facetype and uvtype and normaltype are set  by the correspondering keyword arguments. \n\nSee also: triangle_mesh, normal_mesh, uv_mesh, uv_normal_mesh\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.vertex_attributes-Tuple{Mesh}","page":"API Reference","title":"GeometryBasics.vertex_attributes","text":"vertex_attributes(mesh::Mesh)\n\nReturns a dictionairy containing the vertex attributes of the given mesh.  Mutating these will change the mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.volume-Tuple{Mesh}","page":"API Reference","title":"GeometryBasics.volume","text":"volume(mesh)\n\nCalculate the signed volume of all tetrahedra. Be sure the orientation of your surface is right.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.volume-Tuple{Triangle}","page":"API Reference","title":"GeometryBasics.volume","text":"volume(triangle)\n\nCalculate the signed volume of one tetrahedron. Be sure the orientation of your surface is right.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private","page":"API Reference","title":"Private","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [GeometryBasics]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false\nPrivate = true","category":"page"},{"location":"api/#GeometryBasics.Ngon","page":"API Reference","title":"GeometryBasics.Ngon","text":"Ngon{D, T, N}(points::NTuple{N, Point{D, T}})\n\nDefines a flat polygon (without holes) in D dimensional space using N points, e.g.:\n\nN 1-2 : Illegal!\nN = 3 : Triangle\nN = 4 : Quadrilateral (or Quad, Or tetragon)\nN = 5 : Pentagon\n...\n\nFor polygons with holes, see Polygon.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.RectT","page":"API Reference","title":"GeometryBasics.RectT","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{N2}, Tuple{N1}, Tuple{StaticArraysCore.SMatrix{N1, N1, T1}, HyperRectangle{N2, T2}}} where {N1, N2, T1, T2}","page":"API Reference","title":"Base.:*","text":"*(m::Mat, h::Rect)\n\nTransform a Rect using a matrix. Maintains axis-align properties so a significantly larger Rect may be generated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.in-Union{Tuple{N}, Tuple{HyperRectangle{N}, HyperRectangle{N}}} where N","page":"API Reference","title":"Base.in","text":"in(b1::Rect, b2::Rect)\n\nCheck if Rect b1 is contained in b2. This does not use strict inequality, so Rects may share faces and this will still return true.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.in-Union{Tuple{N}, Tuple{T}, Tuple{Union{NTuple{N, T}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where {N, T}, HyperRectangle{N, T}}} where {T, N}","page":"API Reference","title":"Base.in","text":"in(pt::VecTypes, b1::Rect{N, T})\n\nCheck if a point is contained in a Rect. This will return true if the point is on a face of the Rect.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.in-Union{Tuple{T}, Tuple{T, Triangle}} where T<:Point","page":"API Reference","title":"Base.in","text":"in(point, triangle)\n\nDetermine if a point is inside of a triangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.intersect-Union{Tuple{N}, Tuple{HyperRectangle{N}, HyperRectangle{N}}} where N","page":"API Reference","title":"Base.intersect","text":"intersect(h1::Rect, h2::Rect)\n\nPerform a intersection between two Rects.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isempty-Union{Tuple{HyperRectangle{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"API Reference","title":"Base.isempty","text":"isempty(h::Rect)\n\nReturn true if any of the widths of h are negative.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.merge-Tuple{AbstractVector{<:Mesh}}","page":"API Reference","title":"Base.merge","text":"merge(meshes::AbstractVector{Mesh})\n\nGenerates a new mesh containing all the data of the individual meshes.\n\nIf all meshes are consistent in their use of FaceViews they will be preserved.  Otherwise all of them will be converted with expand_faceviews(mesh).\n\nThis function will generate views in the new mesh which correspond to the  inputs of this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.union-Union{Tuple{N}, Tuple{HyperRectangle{N}, HyperRectangle{N}}} where N","page":"API Reference","title":"Base.union","text":"union(r1::Rect{N}, r2::Rect{N})\n\nReturns a new Rect{N} which contains both r1 and r2.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.mesh-Tuple{AbstractGeometry}","page":"API Reference","title":"GeometryBasics.mesh","text":"mesh(primitive::GeometryPrimitive[; pointtype = Point, facetype = GLTriangleFace, vertex_attributes...])\n\nCreates a mesh from a given primitive with the given pointtype and facetype. \n\nThis method only generates positions and faces from the primitive. Additional vertex attributes like normals and texture coordinates can be given as extra keyword arguments.\n\nNote that vertex attributes that are nothing get removed before creating a mesh.\n\nSee also: triangle_mesh, normal_mesh, uv_mesh, uv_normal_mesh\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.mesh-Union{Tuple{AbstractVector{P}}, Tuple{P}} where P<:(Point2)","page":"API Reference","title":"GeometryBasics.mesh","text":"mesh(polygon::AbstractVector{P}; pointtype=P, facetype=GLTriangleFace)\n\nCreate a mesh from a polygon given as a vector of points, using triangulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.mesh-Union{Tuple{FT}, Tuple{AbstractVector{<:Point}, AbstractVector{FT}}} where FT<:AbstractFace","page":"API Reference","title":"GeometryBasics.mesh","text":"mesh(positions, faces[, facetype = GLTriangleFace, vertex_attributes...])\n\nCreates a mesh from the given positions and faces. Other vertex attributes like normals and texture coordinates can be added as keyword arguments.\n\nNote that vertex attributes that are nothing get removed before creating a mesh.\n\nSee also:normal_mesh\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.mesh-Union{Tuple{Mesh{D, T, FT, Names, VAT, FVT} where {Names, VAT<:(Tuple{var\"#s11\", Vararg{Union{AbstractVector{T}, FaceView{T, AVT} where AVT<:AbstractVector{T}} where T}} where var\"#s11\"<:AbstractArray{Point{D, T}, 1}), FVT<:AbstractVector{FT}}}, Tuple{FT}, Tuple{T}, Tuple{D}} where {D, T, FT<:AbstractFace}","page":"API Reference","title":"GeometryBasics.mesh","text":"mesh(mesh::Mesh[; pointtype = Point, facetype = GLTriangleFace, vertex_attributes...]\n\nRecreates the given mesh with the given pointtype, facetype and vertex  attributes. If the new mesh would match the old mesh, the old mesh is returned instead.\n\nNote that vertex attributes that are nothing get removed before creating a mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.orthogonal_vector-Tuple{Any, Any, Any}","page":"API Reference","title":"GeometryBasics.orthogonal_vector","text":"orthogonal_vector(p1, p2, p3)\n\nCalculates an orthogonal vector cross(p2 - p1, p3 - p1) to a plane described by 3 points p1, p2, p3. \n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.remove_duplicates-Union{Tuple{AbstractVector{FT}}, Tuple{FT}} where FT<:AbstractFace","page":"API Reference","title":"GeometryBasics.remove_duplicates","text":"remove_duplicates(faces)\n\nUses a Dict to remove duplicates from the given faces.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.split-Tuple{HyperRectangle, Any, Integer}","page":"API Reference","title":"GeometryBasics.split","text":"split(rectangle, axis, value)\n\nSplits an Rect into two along an axis at a given location.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.split_mesh","page":"API Reference","title":"GeometryBasics.split_mesh","text":"split_mesh(mesh::Mesh, views::Vector{UnitRange{Int}} = mesh.views)\n\nCreates a new mesh containing faces(mesh)[range] for each range in views. This also removes unused vertices.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Polygons","page":"Polygons","title":"Polygons","text":"","category":"section"},{"location":"primitives/#Primitives","page":"Primitives","title":"Primitives","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"In GeometryBasics.jl, a GeometryPrimitive is an object from which a mesh can be constructed.","category":"page"},{"location":"primitives/#Existing-GeometryPrimitives","page":"Primitives","title":"Existing GeometryPrimitives","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"GeometryBasics comes with a few predefined primitives:","category":"page"},{"location":"primitives/#HyperRectangle","page":"Primitives","title":"HyperRectangle","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A Rect{D, T} = HyperRectangle{D, T} is a D-dimensional axis-aligned  hyperrectangle defined by an origin and a size.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"using GeometryBasics\nr1 = HyperRectangle{4, Float64}(Point{4, Float64}(0), Vec{4, Float64}(1))\nr2 = Rect3f(Point3f(-1), Vec3f(2))\nr3 = Rect2i(0, 0, 1, 1)","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Rect2 supports normal and texture coordinate generation as well as tessellation. Without tessellation, the coordinates of 2D Rects are defined in anti-clockwise order. Rect3 supports normals and texture coordinates, but not tessellation.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Shorthands:","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":" T(eltype) Float64 Float32 Int UInt\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N} Rectui{N}\n2 Rect2{T} Rect2d Rect2f Rect2i Rect2ui\n3 Rect3{T} Rect3d Rect3f Rect3i Rect3ui","category":"page"},{"location":"primitives/#Sphere-and-Circle","page":"Primitives","title":"Sphere and Circle","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Circle and Sphere are the 2 and 3 dimensional variants of HyperSphere.  They are defined by an origin and a radius. While you can technically create a HyperSphere of any dimension, decomposition is only defined in 2D and 3D.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"using GeometryBasics","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"s1 = HyperSphere{4, Int}(Point{4, Int}(0), 5)\ns2 = Sphere(Point3f(0, 0, 1), 1)\ns3 = Circle(Point2d(0), 2.0)","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Circle and Sphere support normal and texture coordinate generation as well as tessellation. The coordinates of Circle are defined in anti-clockwise order.","category":"page"},{"location":"primitives/#Cylinder","page":"Primitives","title":"Cylinder","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A Cylinder is a 3D shape defined by two points and a radius.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"using GeometryBasics","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"c = Cylinder(Point3f(-1, 0, 0), Point3f(0, 0, 1), 0.3f0) # start point, end point, radius","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Cylinder supports normals an Tessellation, but currently no texture coordinates.","category":"page"},{"location":"primitives/#Pyramid","page":"Primitives","title":"Pyramid","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Pyramid corresponds to a pyramid shape with a square base and four triangles coming together into a sharp point. It is defined by by the center point of the base, its height and its width.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"using GeometryBasics","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"p = Pyramid(Point3f(0), 1f0, 0.3f0) # center, height, width","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Pyramid supports normals, but currently no texture coordinates or tessellation","category":"page"},{"location":"primitives/#Tessellation","page":"Primitives","title":"Tessellation","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"In GeometryBasics Tessellation is a wrapper type for primitives which communicates how dense the mesh generated from one should be.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"using GeometryBasics","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"t = Tessellation(Cylinder(Point3f(0), Point3f(0,0,1), 0.2), 32) # 32 vertices for each circle\nnormal_mesh(t)\n\nt = Tessellation(Rect2(Point2f(0), Vec2f(1)), (8, 6)) # 8 vertices in x direction by 6 in y direction\ntriangle_mesh(t)","category":"page"},{"location":"primitives/#Primitive-Interface-/-Implementing-a-new-GeometryPrimitive","page":"Primitives","title":"Primitive Interface / Implementing a new GeometryPrimitive","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Every primitive should inherit from GeometryPrimitive{Dim, eltype} and implement at least coordinates(primitive) and faces(primitive) so that a mesh can be build from it. This will also be enough to automatically generate normals for a 3D primitive and texture coordinates for a 2D primitive. You can also implement functions to generate them directly with normals(primitive) and texturecoordinates(primitive). Depending on your primitive this might be necessary to get the normals and uvs you want.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"To be compatible with Tessellation all of the functions mentioned above should implement a second tessellation argument. This will be the second argument passed to the Tessellation constructor. It's up to you to decide what makes sense here, though typically it's just an integer that more or less corresponds to the number of generated vertices.","category":"page"},{"location":"primitives/#Example","page":"Primitives","title":"Example","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"As an example, let's implement a parallelepiped, i.e. a 3D version or a parallelogram. In this case we need an origin and 3 vectors telling us how far and in which directions the object extends.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"struct Parallelepiped{T} <: GeometryPrimitive{3, T}\n    origin::Point{3, T}\n    v1::Vec{3, T}\n    v2::Vec{3, T}\n    v3::Vec{3, T}\nend","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Like the Rect{3}, this object comes with 8 unique positions which we want to return as its coordinates.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"function GeometryBasics.coordinates(primitive::Parallelepiped{T}) where {T}\n    o = primitive.origin\n    v1 = primitive.v1; v2 = primitive.v2; v3 = primitive.v3\n    return Point{3, T}[o, o+v2, o+v1+v2, o+v1,  o+v3, o+v2+v3, o+v1+v2+v3, o+v1+v3]\nend","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"To connect these points into a mesh, we need to generate a set of faces. The faces of a prallelepiped are parallelograms, which we can describe with QuadFace.  Here we should be concious of the winding direction of faces. They are often used to determine the front vs the backside of a (2D) face. For example GeometryBasics normal generation and OpenGL's backface culling assume a counter-clockwise windig direction to correspond to a front-facing face. This means that if we look at a face from outside the shape, the positions referred to by that face should be ordered counter-clockwise. With that in mind the faces of our primitive become:","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"function GeometryBasics.faces(::Parallelepiped)\n    return QuadFace{Int}[\n        (1, 2, 3, 4), (5, 8, 7, 6), # facing -n3, +n3 (n3 being the normal of v1 x v2)\n        (1, 5, 6, 2), (4, 3, 7, 8), # facing -n2, +n2\n        (2, 6, 7, 3), (1, 4, 8, 5), # facing -n1, +n1\n    ]\nend","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Note that you can check the correct winding direction fairly easily with Makie and the default generated normals. After implementing faces and coordinates, you can create a mesh plot of your primitive with Makie.mesh(primitive). If the mesh reacts to light in a reasonable way, i.e. gets brighter when light shines on it, then your faces have the correct winding direction. (It maybe useful to compare to other primitives like Sphere(Point3f(0), 1f0) here.)","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Next on our TODO list are normals. The default normals produced by GeometryBasics.normal(primitive) are vertex normals, which assume that a primitive to be smooth. Since this is not the case for our primitive, we need to implement custom normals. Here we could rely on GeometryBasics.face_normal() which returns a normal per face, but for this example we will implement them ourselves.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"For our shape we want one normal per face, pointing in the normal direction of the corresponding 2D plane. We can calculate the normal vector as n = normalize(cross(v, w)) where v and w correspond to combinations of v1, v2 and v3. To get them to act per face rather than per vertex, we need to overwrite the faces generated by faces(). We can do that by creating a FaceView with a new set of faces which only act on normals. Each of these new faces needs to refer to one normal by index to get what we want.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"using LinearAlgebra\nfunction GeometryBasics.normals(primitive::Parallelepiped)\n    n1 = normalize(cross(primitive.v2, primitive.v3))\n    n2 = normalize(cross(primitive.v3, primitive.v1))\n    n3 = normalize(cross(primitive.v1, primitive.v2))\n    ns = [-n3, n3, -n2, n2, -n1, n1]\n    fs = QuadFace{Int}[1, 2, 3, 4, 5, 6] # = [QuadFace{Int}(1), QuadFace{Int}(2), ...]\n    return FaceView(ns, fs)\nend","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"As the last piece of the interface we can implement texture coordinates. They generally refer to a 2D image with normalized 2D coordinates on a per-vertex basis. There are many ways to define these coordinates. Here we will partition the image in 2x3 even sized rectangular sections, split by the sign of the normal directions defined above.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"function GeometryBasics.texturecoordinates(::Parallelepiped{T}) where {T}\n    uvs = [Vec2f(x, y) for x in range(0, 1, length=4) for y in range(0, 1, 3)]\n    fs = QuadFace{Int}[\n        (1, 2, 5, 4),   (2, 3, 6, 5),\n        (4, 5, 8, 7),   (5, 6, 9, 8), \n        (7, 8, 11, 10), (8, 9, 12, 11)\n    ]\n    return FaceView(uvs, fs)\nend","category":"page"},{"location":"decomposition/#Decomposition","page":"Decomposition","title":"Decomposition","text":"","category":"section"},{"location":"decomposition/#decompose-functions","page":"Decomposition","title":"decompose functions","text":"","category":"section"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"The decompose functions allow you to grab certain data from an AbstractGeometry like a mesh or primitive and convert it to a requested type, if possible. They can also be used to convert an array of e.g. faces into a different face type directly. The default decomposition implemented by GeoemtryBasics are:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"decompose(::Type{<: Point}, source) which collects data from source using coordinates(source) and converts it to the given point type.\ndecompose_normals([::Type{<: Vec},] source) = decompose([::Type{Normals{<: Vec}}},] source) which collects data with normals(source) and converts it to the given Vec type.\ndecompose_uv([::Type{<: Vec},] source) = decompose([::Type{UV{<: Vec}}},] source) which collects data with texturecoordinates(source) and converts it to the given Vec type. This function also exists with UVW texture coordinates.\ndecompose(::Type{<: AbstractFace}, source) which collects data with faces(source) and converts it to the given face type. ","category":"page"},{"location":"decomposition/#Extending-decompose","page":"Decomposition","title":"Extending decompose","text":"","category":"section"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"For decompose to work there needs to be a conversion from some element type to some target type.  GeometryBasics relies on GeometryBasics.convert_simplex(TargetType, value) for this. If you want to add new types to decompose, e.g. a new face type, you will need to add a method to that function.","category":"page"},{"location":"decomposition/#Primitive-decomposition","page":"Decomposition","title":"Primitive decomposition","text":"","category":"section"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"GeometryBasics defines an interface to decompose geometry primitives into vertex attributes and faces. The interface includes four functions:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"coordinates(primitive[, nvertices]) which produces the positions associated with the primitive\nfaces(primitive[, nvertices]) which produces the faces which connect the vertex positions to a mesh\nnormals(primitive[, nvertices]) which optionally provide normal vectors of the primitive\ntexturecoordinates(primitive[, nvertices]) which optional provide texture coordinates (uv/uvw) of the primitive","category":"page"},{"location":"#GeometryBasics.jl","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"","category":"section"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Basic geometry types.","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"This package aims to offer a standard set of geometry types that easily work with metadata, query frameworks on geometries and different memory layouts. The aim is to create a solid basis for graphics/plotting, finite element analysis, geo applications, and general geometry manipulations - while offering a Julian API that still allows performant C-interop.","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"This package is a replacement for the discontinued GeometryTypes.","category":"page"},{"location":"#Quick-start","page":"GeometryBasics.jl","title":"Quick start","text":"","category":"section"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Create some points:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"using GeometryBasics\n\np1 = Point(3, 1)\np2 = Point(1, 3);\np3 = Point(4, 4);","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Connect pairs of points as line segments:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"l1 = Line(p1, p2)\nl2 = Line(p2, p3);","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Or connect multiple points as a linestring:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"LineString([p1, p2, p3])","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"You can also create polygons from points:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Polygon(Point{2, Int}[(3, 1), (4, 4), (2, 4), (1, 2), (3, 1)])","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Create a rectangle placed at the origin with unit width and height:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"rect = Rect(Vec(0.0, 0.0), Vec(1.0, 1.0))","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Decompose the rectangle into two triangular faces:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"rect_faces = decompose(TriangleFace{Int}, rect)","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Decompose the rectangle into four positions:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"rect_positions = decompose(Point{2, Float64}, rect)","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Combine the vertices and faces into a triangle mesh:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"mesh = Mesh(rect_positions, rect_faces)","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Use GeometryBasics.mesh to get a mesh directly from a geometry:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"mesh = GeometryBasics.mesh(rect)","category":"page"},{"location":"meshes/#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"GeometryBasics defines two mesh types to work with - Mesh and MetaMesh","category":"page"},{"location":"meshes/#Mesh","page":"Meshes","title":"Mesh","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"Mesh","category":"page"},{"location":"meshes/#GeometryBasics.Mesh-meshes","page":"Meshes","title":"GeometryBasics.Mesh","text":"Mesh{PositionDim, PositionType, FaceType, VertexAttributeNames, VertexAttributeTypes, FaceVectorType} <: AbstractMesh{PositionDim, PositionType} <: AbstractGeometry{PositionDim, PositionType}\n\nThe type of a concrete mesh. The associated struct contains 3 fields:\n\nstruct Mesh{...}\n    vertex_attributes::NamedTuple{VertexAttributeNames, VertexAttributeTypes}\n    faces::FaceVectorType\n    views::Vector{UnitRange{Int}}\nend\n\nA vertex typically carries multiple distinct pieces of data, e.g. a position,  a normal, a texture coordinate, etc. We call those pieces of data vertex  attributes. The vertex_attributes field contains the name and a collection  <: AbstractVector or <: FaceView for each attribute. The n-th element of that collection is the value of the corresponding attribute for the n-th vertex.\n\n#                   vertex       1        2        3\nvertex_attributes[:position] = [pos1,    pos2,    pos3,    ...]\nvertex_attributes[:normal]   = [normal1, normal2, normal3, ...]\n...\n\nA NamedTuple is used here to allow different meshes to carry different vertex  attributes while also keeping things type stable. The constructor enforces a  few restrictions:\n\nThe first attribute must be named position and must have a Point{PositionDim, PositionType} eltype.\nEach vertex attribute must refer to the same number of vertices. (All vertex attributes defined by \n\nAbstractVector must match in length. For FaceViews, the number of faces needs to match.)\n\nSee also: vertex_attributes, coordinates, normals,  texturecoordinates, decompose, FaceView,  expand_faceviews\n\nThe faces field is a collection <: AbstractVector{FaceType} containing faces  that describe how vertices are connected. Typically these are (GL)TriangleFaces or QuadFaces, but they can be any collection of vertex indices <: AbstractFace.\n\nSee also: faces, decompose\n\nThe views field can be used to separate the mesh into mutliple submeshes. Each  submesh is described by a \"view\" into the faces vector, i.e. submesh n uses  mesh.faces[mesh.views[n]]. A Mesh can be constructed without views, which  results in an empty views vector. \n\nSee also: merge, split_mesh\n\n\n\n\n\n","category":"type"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"You can get data from a mesh using a few interface functions:","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"vertex_attributes(mesh) = mesh.vertex_attributes\ncoordinates(mesh) = mesh.vertex_attributes[:position]\nnormals(mesh) = mesh.vertex_attributes[:normal]\ntexturecoordinates(mesh) = mesh.vertex_attributes[:uv]\nfaces(mesh) = mesh.faces","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"You can also grab the contents of mesh.vertex_attributes as if they were fields of the Mesh, e.g. mesh.position works.","category":"page"},{"location":"meshes/#FaceView","page":"Meshes","title":"FaceView","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"FaceView","category":"page"},{"location":"meshes/#GeometryBasics.FaceView-meshes","page":"Meshes","title":"GeometryBasics.FaceView","text":"FaceView(data, faces)\n\nA FaceView is an alternative to passing a vertex attribute directly to a mesh.  It bundles data with a new set of faces which may index that data differently from the faces defined in a mesh. This can be useful to avoid duplication in data.\n\nFor example, data can be defined per face by giving each face just one (repeated) index:\n\nper_face_normals = FaceView(\n    normals,                 # one per face\n    FT.(eachindex(normals))  # with FT = facetype(mesh)\n)\n\nIf you need a mesh with strictly per-vertex data, e.g. for rendering, you can use  expand_faceviews(mesh) to convert every vertex attribute to be per-vertex. This will duplicate data and reorder faces as needed.\n\nYou can get the data of a FaceView with values(faceview) and the faces with faces(faceview).\n\n\n\n\n\n","category":"type"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"The purpose of FaceView is to allow you to add data that doesn't use the same vertex indices as mesh.faces As a minimal example consider a mesh that is just one triangle, i.e. 3 position and one triangle face TriangleFace(1,2,3). Let's say we want to add a flat color to the triangle. In this case we only have one color, but our face refers to 3 different vertices (3 different positions). To avoid duplicating the color data, we can instead define a new triangle face TriangleFace(1) and add the color attribute as a FaceView([color], [TriangleFace(1)]). If we ever need the mesh to be defined with just one common set of faces, i.e. no FaceView and appropriately duplicated vertex data, we can use expand_faceviews(mesh) to generate it.","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"On a larger scale this can be useful for memory and performance reason, e.g. when you do calculations with vertex attributes. It can also simplify some definitions, like for example Rect3. In that case we have 8 positions and 6 normals with FaceViews, or 24 without (assuming per-face normals).","category":"page"},{"location":"meshes/#MetaMesh","page":"Meshes","title":"MetaMesh","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"MetaMesh","category":"page"},{"location":"meshes/#How-to-create-a-mesh","page":"Meshes","title":"How to create a mesh","text":"","category":"section"},{"location":"meshes/#GeometryBasics","page":"Meshes","title":"GeometryBasics","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"In GeometryBasics you mainly create meshes from primitives using a few constructors:","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"triangle_mesh(primitive) generates the most basic mesh (i.e. positions and faces)\nnormal_mesh(primitive) generates a mesh with normals (generated if the primitive doesn't implement normal())\nuv_mesh(primitive) generates a mesh with texture coordinates (generated if the primitive doesn't implement texturecoordinates())\nuv_normal_mesh(primitive) generates a mesh with normals and texture coordinates","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"Each of these constructors also includes keyword arguments for setting types, i.e. pointtype, facetype, normaltype and uvtype as appropriate. Of course you can also construct a mesh directly from data, either with there various Mesh() or GeometryBasics.mesh() constructors. The latter also include a pointtype and facetype conversion.","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"Finally there is also a merge(::Vector{Mesh}) function which combines multiple meshes into a single one. Note that this doesn't remove any data (e.g. hidden or duplicate vertices), and may remove FaceViews if they are incompatible between meshes.","category":"page"},{"location":"meshes/#Meshing.jl","page":"Meshes","title":"Meshing.jl","text":"","category":"section"},{"location":"meshes/#MeshIO.jl","page":"Meshes","title":"MeshIO.jl","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"The MeshIO.jl package provides load/save support for several file formats which store meshes.","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"using GLMakie, GLMakie.FileIO, GeometryBasics\n\nm = load(GLMakie.assetpath(\"cat.obj\"))\nGLMakie.mesh(m; color=load(GLMakie.assetpath(\"diffusemap.png\")), axis=(; show_axis=false))","category":"page"}]
}
