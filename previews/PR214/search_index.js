var documenterSearchIndex = {"docs":
[{"location":"metadata/#Metadata","page":"Metadata","title":"Metadata","text":"","category":"section"},{"location":"metadata/#Meta","page":"Metadata","title":"Meta","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"The Meta method provides metadata handling capabilities in GeometryBasics. Similarly to remove the metadata and keep only the geometry, use metafree, and for vice versa i.e., remove the geometry and keep the metadata use meta.","category":"page"},{"location":"metadata/#Syntax","page":"Metadata","title":"Syntax","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"meta(geometry, meta::NamedTuple)\nmeta(geometry; meta...)\n\nmetafree(meta-geometry)\nmeta(meta-geometry)","category":"page"},{"location":"metadata/#Examples","page":"Metadata","title":"Examples","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"using GeometryBasics\np1 = Point(2.2, 3.6)\npoi = meta(p1, city=\"Abuja\", rainfall=1221.2)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Metadata is stored in a NamedTuple and can be retrieved as such:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"meta(poi)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Specific metadata attributes can be directly retrieved:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"poi.rainfall\nmetafree(poi)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Metatypes are predefined for geometries:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"multipoi = MultiPointMeta([p1], city=\"Abuja\", rainfall=1221.2)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"(In the above example we have also used a geometry-specific meta method.)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"GeometryBasics.MetaType(Polygon)\nGeometryBasics.MetaType(Mesh)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"The metageometry objects are infact composed of the original geometry types.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"GeometryBasics.MetaFree(PolygonMeta)\nGeometryBasics.MetaFree(MeshMeta)","category":"page"},{"location":"metadata/#MetaT","page":"Metadata","title":"MetaT","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"In GeometryBasics we can have tabular layout for a collection of meta-geometries by putting them into a StructArray that extends the Tables.jl API.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"In practice it's not necessary for the geometry or metadata types to be consistent. For example, a geojson format can have heterogeneous geometries. Hence, such cases require automatic widening of the geometry data types to the most appropriate type. The MetaT method works around the fact that, a collection of geometries and metadata of different types can be represented tabularly whilst widening to the appropriate type.","category":"page"},{"location":"metadata/#Syntax-2","page":"Metadata","title":"Syntax","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"MetaT(geometry, meta::NamedTuple)\nMetaT(geometry; meta...)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Returns a MetaT that holds a geometry and its metadata MetaT acts the same as Meta method. The difference lies in the fact that it is designed to handle geometries and metadata of different/heterogeneous types.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"For example, while a Point MetaGeometry is a PointMeta, the MetaT representation is MetaT{Point}.","category":"page"},{"location":"metadata/#Examples-2","page":"Metadata","title":"Examples","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"MetaT(Point(1, 2), city = \"Mumbai\")","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"For a tabular representation, an iterable of MetaT types can be passed on to a meta_table method.","category":"page"},{"location":"metadata/#Syntax-3","page":"Metadata","title":"Syntax","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"meta_table(iter)","category":"page"},{"location":"metadata/#Examples-3","page":"Metadata","title":"Examples","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Create an array of 2 linestrings:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"ls = [LineString([Point(i, i+1), Point(i-1,i+5)]) for i in 1:2];\ncoordinates.(ls)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Create a multi-linestring:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"mls = MultiLineString(ls);\ncoordinates.(mls)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Create a polygon:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"poly = Polygon(Point{2, Int}[(40, 40), (20, 45), (45, 30), (40, 40)]);\ncoordinates(poly)","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Put all geometries into an array:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"geom = [ls..., mls, poly];","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Generate some random metadata:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"prop = [(country_states = \"India$(i)\", rainfall = (i*9)/2) for i in 1:4]\nfeat = [MetaT(i, j) for (i,j) = zip(geom, prop)]; # create an array of MetaT","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"We can now generate a StructArray / Table with meta_table:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"sa = meta_table(feat);","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"The data can be accessed through sa.main and the metadata through sa.country_states and sa.rainfall. Here we print only the type names of the data items for brevity:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"[nameof.(typeof.(sa.main)) sa.country_states sa.rainfall]","category":"page"},{"location":"metadata/#Disadvantages","page":"Metadata","title":"Disadvantages","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"The MetaT is pretty generic in terms of geometry types, it's not subtype to geometries. eg : A MetaT{Point, NamedTuple{Names, Types}} is not subtyped to AbstractPoint like a PointMeta is.\nThis might cause problems on using MetaT with other constructors/methods inside or even outside GeometryBasics methods designed to work with the main Meta types.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Exports","page":"API Reference","title":"Exports","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [GeometryBasics]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api/#GeometryBasics.AbstractGeometry","page":"API Reference","title":"GeometryBasics.AbstractGeometry","text":"Abstract Geometry in R{Dim} with Number type T\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.AbstractMesh","page":"API Reference","title":"GeometryBasics.AbstractMesh","text":"AbstractMesh\n\nAn abstract mesh is a collection of Polytope elements (Simplices / Ngons). The connections are defined via faces(mesh), the coordinates of the elements are returned by coordinates(mesh). Arbitrary meta information can be attached per point or per face\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Circle","page":"API Reference","title":"GeometryBasics.Circle","text":"Circle{T}\n\nAn alias for a HyperSphere of dimension 2. (i.e. HyperSphere{2, T})\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Cylinder","page":"API Reference","title":"GeometryBasics.Cylinder","text":"Cylinder{N, T}\n\nA Cylinder is a 2D rectangle or a 3D cylinder defined by its origin point, its extremity and a radius. origin, extremity and r, must be specified.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Cylinder2","page":"API Reference","title":"GeometryBasics.Cylinder2","text":"Cylinder2{T}\nCylinder3{T}\n\nA Cylinder2 or Cylinder3 is a 2D/3D cylinder defined by its origin point, its extremity and a radius. origin, extremity and r, must be specified.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.FaceView","page":"API Reference","title":"GeometryBasics.FaceView","text":"FaceView{Element, Point, Face, P, F}\n\nFaceView enables to link one array of points via a face array, to generate one abstract array of elements. E.g., this becomes possible:\n\nx = FaceView(rand(Point3f, 10), TriangleFace[(1, 2, 3), (2, 4, 5), ...])\nx[1] isa Triangle == true\nx isa AbstractVector{<: Triangle} == true\n# This means we can use it as a mesh:\nMesh(x) # should just work!\n# Can also be used for Points:\n\nlinestring = FaceView(points, LineFace[...])\nPolygon(linestring)\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.HyperRectangle","page":"API Reference","title":"GeometryBasics.HyperRectangle","text":"HyperRectangle{N, T}\n\nA HyperRectangle is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the origin and widths fields, whose indices correspond to each of the N axes.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.HyperSphere","page":"API Reference","title":"GeometryBasics.HyperSphere","text":"HyperSphere{N, T}\n\nA HyperSphere is a generalization of a sphere into N-dimensions. A center and radius, r, must be specified.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.LineString","page":"API Reference","title":"GeometryBasics.LineString","text":"LineString(points::AbstractVector{<: AbstractPoint}, skip = 1)\n\nCreates a LineString from a vector of points. With skip == 1, the default, it will connect the line like this:\n\npoints = Point[a, b, c, d]\nlinestring = LineString(points)\n@assert linestring == LineString([a => b, b => c, c => d])\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.LineString-2","page":"API Reference","title":"GeometryBasics.LineString","text":"LineString(points::AbstractVector{<: AbstractPoint}, indices::AbstractVector{<: Integer}, skip = 1)\n\nCreates a LineString from a vector of points and an index list. With skip == 1, the default, it will connect the line like this:\n\npoints = Point[a, b, c, d]; faces = [1, 2, 3, 4]\nlinestring = LineString(points, faces)\n@assert linestring == LineString([a => b, b => c, c => d])\n\nTo make a segmented line, set skip to 2\n\npoints = Point[a, b, c, d]; faces = [1, 2, 3, 4]\nlinestring = LineString(points, faces, 2)\n@assert linestring == LineString([a => b, c => d])\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.LineString-3","page":"API Reference","title":"GeometryBasics.LineString","text":"LineString(points::AbstractVector{<:AbstractPoint})\n\nA LineString is a geometry of connected line segments\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Mesh","page":"API Reference","title":"GeometryBasics.Mesh","text":"Mesh <: AbstractVector{Element}\n\nThe concrete AbstractMesh implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.MetaT","page":"API Reference","title":"GeometryBasics.MetaT","text":"MetaT(geometry, meta::NamedTuple)\nMetaT(geometry; meta...)\n\nReturns a MetaT that holds a geometry and its metadata\n\nMetaT acts the same as Meta method. The difference lies in the fact that it is designed to handle geometries and metadata of different/heterogeneous types.\n\neg: While a Point MetaGeometry is a PointMeta, the MetaT representation is MetaT{Point} The downside being it's not subtyped to AbstractPoint like a PointMeta is.\n\nExample:\n\njulia> MetaT(Point(1, 2), city = \"Mumbai\")\nMetaT{Point{2,Int64},(:city,),Tuple{String}}([1, 2], (city = \"Mumbai\",))\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.MultiPoint","page":"API Reference","title":"GeometryBasics.MultiPoint","text":"MultiPoint(points::AbstractVector{AbstractPoint})\n\nA collection of points\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.MultiPolygon","page":"API Reference","title":"GeometryBasics.MultiPolygon","text":"MultiPolygon(polygons::AbstractPolygon)\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.NormalMesh","page":"API Reference","title":"GeometryBasics.NormalMesh","text":"NormalMesh{Dim, T}\n\nPlainMesh with normals meta at each point. normalmesh.normals isa AbstractVector{Vec3f}\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.NormalUVMesh","page":"API Reference","title":"GeometryBasics.NormalUVMesh","text":"NormalUVMesh{Dim, T}\n\nPlainMesh with normals and uv meta at each point. normalmesh.normals isa AbstractVector{Vec3f} normalmesh.uv isa AbstractVector{Vec2f}\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.NormalUVWMesh","page":"API Reference","title":"GeometryBasics.NormalUVWMesh","text":"NormalUVWMesh{Dim, T}\n\nPlainMesh with normals and uvw (texture coordinates in 3D) meta at each point. normalmesh.normals isa AbstractVector{Vec3f} normalmesh.uvw isa AbstractVector{Vec3f}\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.OffsetInteger","page":"API Reference","title":"GeometryBasics.OffsetInteger","text":"OffsetInteger{O, T}\n\nOffsetInteger type mainly for indexing.\n\nO - The offset relative to Julia arrays. This helps reduce copying when\n\ncommunicating with 0-indexed systems such as OpenGL.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.PlainMesh","page":"API Reference","title":"GeometryBasics.PlainMesh","text":"PlainMesh{Dim, T}\n\nTriangle mesh with no meta information (just points + triangle faces)\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Polygon","page":"API Reference","title":"GeometryBasics.Polygon","text":"Polygon(exterior::AbstractVector{<:Point})\nPolygon(exterior::AbstractVector{<:Point}, interiors::Vector{<:AbstractVector{<:AbstractPoint}})\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Polytope","page":"API Reference","title":"GeometryBasics.Polytope","text":"Geometry made of N connected points. Connected as one flat geometry, it makes a Ngon / Polygon. Connected as volume it will be a Simplex / Tri / Cube. Note That Polytope{N} where N == 3 denotes a Triangle both as a Simplex or Ngon.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Polytope-Union{Tuple{IT}, Tuple{T}, Tuple{Dim}, Tuple{N}, Tuple{Type{<:AbstractPoint{Dim, T}}, Type{<:GeometryBasics.AbstractNgonFace{N, IT}}}} where {N, Dim, T, IT}","page":"API Reference","title":"GeometryBasics.Polytope","text":"The Ngon Polytope element type when indexing an array of points with a SimplexFace\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Polytope-Union{Tuple{T}, Tuple{Dim}, Tuple{N}, Tuple{Type{<:AbstractPoint{Dim, T}}, Type{<:GeometryBasics.AbstractSimplexFace{N}}}} where {N, Dim, T}","page":"API Reference","title":"GeometryBasics.Polytope","text":"The Simplex Polytope element type when indexing an array of points with a SimplexFace\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Polytope-Union{Tuple{T}, Tuple{NDim}, Tuple{N}, Tuple{Type{<:GeometryBasics.Ngon{Dim, T, N, P} where {Dim, T, P}}, Type{<:AbstractPoint{NDim, T}}}} where {N, NDim, T}","page":"API Reference","title":"GeometryBasics.Polytope","text":"The fully concrete Ngon type, when constructed from a point type!\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Polytope-Union{Tuple{T}, Tuple{NDim}, Tuple{N}, Tuple{Type{<:NSimplex{N}}, Type{<:AbstractPoint{NDim, T}}}} where {N, NDim, T}","page":"API Reference","title":"GeometryBasics.Polytope","text":"The fully concrete Simplex type, when constructed from a point type!\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Rect","page":"API Reference","title":"GeometryBasics.Rect","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect-Tuple{Vararg{Number}}","page":"API Reference","title":"GeometryBasics.Rect","text":"Rect(vals::Number...)\n\nRect(vals::Number...)\n\nRect constructor for individually specified intervals. e.g. Rect(0,0,1,2) has origin == Vec(0,0) and width == Vec(1,2)\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Rect-Union{Tuple{AbstractArray{PT}}, Tuple{PT}, Tuple{T1}, Tuple{N1}} where {N1, T1, PT<:AbstractPoint}","page":"API Reference","title":"GeometryBasics.Rect","text":"Construct a HyperRectangle enclosing all points.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.Rect2","page":"API Reference","title":"GeometryBasics.Rect2","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect2d","page":"API Reference","title":"GeometryBasics.Rect2d","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect2f","page":"API Reference","title":"GeometryBasics.Rect2f","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect2i","page":"API Reference","title":"GeometryBasics.Rect2i","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect3","page":"API Reference","title":"GeometryBasics.Rect3","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect3d","page":"API Reference","title":"GeometryBasics.Rect3d","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect3f","page":"API Reference","title":"GeometryBasics.Rect3f","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rect3i","page":"API Reference","title":"GeometryBasics.Rect3i","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rectd","page":"API Reference","title":"GeometryBasics.Rectd","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Rectf","page":"API Reference","title":"GeometryBasics.Rectf","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Recti","page":"API Reference","title":"GeometryBasics.Recti","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Simplex","page":"API Reference","title":"GeometryBasics.Simplex","text":"A Simplex is a generalization of an N-dimensional tetrahedra and can be thought of as a minimal convex set containing the specified points.\n\nA 0-simplex is a point.\nA 1-simplex is a line segment.\nA 2-simplex is a triangle.\nA 3-simplex is a tetrahedron.\n\nNote that this datatype is offset by one compared to the traditional mathematical terminology. So a one-simplex is represented as Simplex{2,T}. This is for a simpler implementation.\n\nIt applies to infinite dimensions. The structure of this type is designed to allow embedding in higher-order spaces by parameterizing on T.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Sphere","page":"API Reference","title":"GeometryBasics.Sphere","text":"Sphere{T}\n\nAn alias for a HyperSphere of dimension 3. (i.e. HyperSphere{3, T})\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.Tesselation","page":"API Reference","title":"GeometryBasics.Tesselation","text":"Tesselation(primitive, nvertices)\n\nFor abstract geometries, when we generate a mesh from them, we need to decide how fine grained we want to mesh them. To transport this information to the various decompose methods, you can wrap it in the Tesselation object e.g. like this:\n\nsphere = Sphere(Point3f(0), 1)\nm1 = mesh(sphere) # uses a default value for tesselation\nm2 = mesh(Tesselation(sphere, 64)) # uses 64 for tesselation\nlength(coordinates(m1)) != length(coordinates(m2))\n\nFor grid based tesselation, you can also use a tuple: ```julia rect = Rect2(0, 0, 1, 1) Tesselation(rect, (5, 5))\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.TriangleMesh","page":"API Reference","title":"GeometryBasics.TriangleMesh","text":"TriangleMesh{Dim, T, PointType}\n\nAbstract Mesh with triangle elements of eltype T.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.TupleView","page":"API Reference","title":"GeometryBasics.TupleView","text":"TupleView{T, N, Skip, A}\n\nTupleView, groups elements of an array as tuples. N is the dimension of the tuple, M tells how many elements to skip to the next tuple. By default TupleView{N} defaults to skip N items.\n\na few examples:\n\n\nx = [1, 2, 3, 4, 5, 6]\nTupleView{2, 1}(x):\n> [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\n\nTupleView{2}(x):\n> [(1, 2), (3, 4), (5, 6)]\n\nTupleView{2, 3}(x):\n> [(1, 2), (4, 5)]\n\nTupleView{3, 1}(x):\n> [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]\n\nTupleView can be used together with reinterpret:\n\nx = [1, 2, 3, 4]\ny = reinterpret(Point{2, Int}, TupleView{2, 1}(x))\n> [Point(1, 2), Point(2, 3), Point(3, 4)]\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.UVMesh","page":"API Reference","title":"GeometryBasics.UVMesh","text":"UVMesh{Dim, T}\n\nPlainMesh with texture coordinates meta at each point. uvmesh.uv isa AbstractVector{Vec2f}\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.area-Union{Tuple{AbstractVector{<:AbstractPoint{2, T}}}, Tuple{T}} where T","page":"API Reference","title":"GeometryBasics.area","text":"area(contour::AbstractVector{AbstractPoint}})\n\nCalculate the area of a polygon.\n\nFor 2D points, the oriented area is returned (negative when the points are oriented clockwise).\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.area-Union{Tuple{FT}, Tuple{VT}, Tuple{AbstractVector{<:AbstractPoint{3, VT}}, AbstractArray{TriangleFace{FT}, 1}}} where {VT, FT}","page":"API Reference","title":"GeometryBasics.area","text":"area(vertices::AbstractVector{AbstractPoint{3}}, faces::AbstractVector{TriangleFace})\n\nCalculate the area of all triangles.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.area-Union{Tuple{FT}, Tuple{VT}, Tuple{AbstractVector{<:AbstractPoint{3, VT}}, TriangleFace{FT}}} where {VT, FT}","page":"API Reference","title":"GeometryBasics.area","text":"area(vertices::AbstractVector{AbstractPoint{3}}, face::TriangleFace)\n\nCalculate the area of one triangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.connect-Union{Tuple{Point}, Tuple{AbstractVector{Point}, Type{<:Polytope}}, Tuple{AbstractVector{Point}, Type{<:Polytope}, Int64}} where Point<:AbstractPoint","page":"API Reference","title":"GeometryBasics.connect","text":"connect(points::AbstractVector{<: AbstractPoint}, P::Type{<: Polytope{N}}, skip::Int = N)\n\nCreates a view that connects a number of points to a Polytope P. Between each polytope, skip elements are skipped untill the next starts. Example: ```julia x = connect(Point[(1, 2), (3, 4), (5, 6), (7, 8)], Line, 2) x == [Line(Point(1, 2), Point(3, 4)), Line(Point(5, 6), Point(7, 8))]\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.convert_simplex-Union{Tuple{N}, Tuple{T}, Tuple{Type{LineFace{T}}, Union{NgonFace{N}, SimplexFace{N}}}} where {T, N}","page":"API Reference","title":"GeometryBasics.convert_simplex","text":"convert_simplex(::Type{Face{2}}, f::Face{N})\n\nExtract all line segments in a Face.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.convert_simplex-Union{Tuple{N}, Tuple{T}, Tuple{Type{TriangleFace{T}}, Union{NgonFace{N}, SimplexFace{N}}}} where {T, N}","page":"API Reference","title":"GeometryBasics.convert_simplex","text":"convert_simplex(::Type{Face{3}}, f::Face{N})\n\nTriangulate an N-Face into a tuple of triangular faces.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.coordinates-Tuple{AbstractVector{<:AbstractPoint}}","page":"API Reference","title":"GeometryBasics.coordinates","text":"coordinates(geometry)\n\nReturns the edges/vertices/coordinates of a geometry. Is allowed to return lazy iterators! Use decompose(ConcretePointType, geometry) to get Vector{ConcretePointType} with ConcretePointType to be something like Point{3, Float32}.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.decompose-Union{Tuple{FaceType}, Tuple{P}, Tuple{Type{FaceType}, AbstractArray{P}}} where {P<:AbstractPoint, FaceType<:AbstractFace}","page":"API Reference","title":"GeometryBasics.decompose","text":"decompose(facetype, contour::AbstractArray{<:AbstractPoint})\n\nTriangulate a Polygon without hole.\n\nReturns a Vector{facetype} defining indexes into contour.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.faces-Tuple{AbstractVector{<:AbstractFace}}","page":"API Reference","title":"GeometryBasics.faces","text":"faces(geometry)\n\nReturns the face connections of a geometry. Is allowed to return lazy iterators! Use decompose(ConcreteFaceType, geometry) to get Vector{ConcreteFaceType} with ConcreteFaceType to be something like TriangleFace{Int}.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.meta-Tuple{MetaT}","page":"API Reference","title":"GeometryBasics.meta","text":"meta(x::MetaT)\nmeta(x::Array{MetaT})\n\nReturns the metadata of a MetaT\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.meta-Tuple{T} where T","page":"API Reference","title":"GeometryBasics.meta","text":"meta(x::MetaObject)\n\nReturns the metadata of x\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.meta_table-Tuple{Any}","page":"API Reference","title":"GeometryBasics.meta_table","text":"Puts an iterable of MetaT's into a StructArray \n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.metafree-Tuple{MetaT}","page":"API Reference","title":"GeometryBasics.metafree","text":"metafree(x::MetaT)\nmetafree(x::Array{MetaT})\n\nFree the MetaT from metadata i.e. returns the geometry/array of geometries\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.normals-Union{Tuple{F}, Tuple{T}, Tuple{AbstractVector{<:AbstractPoint{3, T}}, AbstractVector{F}}} where {T, F<:NgonFace}","page":"API Reference","title":"GeometryBasics.normals","text":"normals{VT,FD,FT,FO}(vertices::Vector{Point{3, VT}},\n                    faces::Vector{Face{FD,FT,FO}},\n                    NT = Normal{3, VT})\n\nCompute all vertex normals.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.pointmeta-Tuple{Mesh}","page":"API Reference","title":"GeometryBasics.pointmeta","text":"pointmeta(mesh::Mesh; meta_data...)\n\nAttaches metadata to the coordinates of a mesh\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.self_intersections-Tuple{AbstractVector{<:AbstractPoint}}","page":"API Reference","title":"GeometryBasics.self_intersections","text":"self_intersections(points::AbstractVector{AbstractPoint})\n\nFinds all self intersections of polygon points\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.split_intersections-Tuple{AbstractVector{<:AbstractPoint}}","page":"API Reference","title":"GeometryBasics.split_intersections","text":"split_intersections(points::AbstractVector{AbstractPoint})\n\nSplits polygon points into it's self intersecting parts. Only 1 intersection is handled right now.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.volume-Tuple{Mesh}","page":"API Reference","title":"GeometryBasics.volume","text":"volume(mesh)\n\nCalculate the signed volume of all tetrahedra. Be sure the orientation of your surface is right.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.volume-Tuple{Triangle}","page":"API Reference","title":"GeometryBasics.volume","text":"volume(triangle)\n\nCalculate the signed volume of one tetrahedron. Be sure the orientation of your surface is right.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private","page":"API Reference","title":"Private","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [GeometryBasics]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false\nPrivate = true","category":"page"},{"location":"api/#GeometryBasics.Ngon","page":"API Reference","title":"GeometryBasics.Ngon","text":"Fixed Size Polygon, e.g.\n\nN 1-2 : Illegal!\nN = 3 : Triangle\nN = 4 : Quadrilateral (or Quad, Or tetragon)\nN = 5 : Pentagon\n...\n\n\n\n\n\n","category":"type"},{"location":"api/#GeometryBasics.RectT","page":"API Reference","title":"GeometryBasics.RectT","text":"const Rect{N,T} = HyperRectangle{N,T}\n\nA rectangle in N dimensions, formally the cartesian product of intervals. See also HyperRectangle. Its aliases are\n\n T(eltype) Float64 Float32 Int\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N}\n2 Rect2{T} Rect2d Rect2f Rect2i\n3 Rect3{T} Rect3d Rect3f Rect3i\n\nThere is an additional unexported alias RectT that simply reverses the order of type parameters: RectT{T,N} == Rect{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*-Union{Tuple{T2}, Tuple{T1}, Tuple{N2}, Tuple{N1}, Tuple{StaticArraysCore.SMatrix{N1, N1, T1}, HyperRectangle{N2, T2}}} where {N1, N2, T1, T2}","page":"API Reference","title":"Base.:*","text":"*(m::Mat, h::Rect)\n\nTransform a Rect using a matrix. Maintains axis-align properties so a significantly larger Rect may be generated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.in-Union{Tuple{N}, Tuple{HyperRectangle{N}, HyperRectangle{N}}} where N","page":"API Reference","title":"Base.in","text":"in(b1::Rect, b2::Rect)\n\nCheck if Rect b1 is contained in b2. This does not use strict inequality, so Rects may share faces and this will still return true.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.in-Union{Tuple{N}, Tuple{T}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where {N, T}, HyperRectangle{N, T}}} where {T, N}","page":"API Reference","title":"Base.in","text":"in(pt::VecTypes, b1::Rect{N, T})\n\nCheck if a point is contained in a Rect. This will return true if the point is on a face of the Rect.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.in-Union{Tuple{T}, Tuple{T, Triangle}} where T<:AbstractPoint","page":"API Reference","title":"Base.in","text":"in(point, triangle)\n\nDetermine if a point is inside of a triangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isempty-Union{Tuple{HyperRectangle{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"API Reference","title":"Base.isempty","text":"isempty(h::Rect)\n\nReturn true if any of the widths of h are negative.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.union-Union{Tuple{N}, Tuple{HyperRectangle{N}, HyperRectangle{N}}} where N","page":"API Reference","title":"Base.union","text":"Perform a union between two Rects.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.MetaFree-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API Reference","title":"GeometryBasics.MetaFree","text":"MetaFree(::Type{T})\n\nReturns the original type containing no metadata for T E.g:\n\nMetaFree(PointMeta) == Point\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.MetaType-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API Reference","title":"GeometryBasics.MetaType","text":"MetaType(::Type{T})\n\nReturns the Meta Type corresponding to T E.g:\n\nMetaType(Point) == PointMeta\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.attributes-Tuple{Any}","page":"API Reference","title":"GeometryBasics.attributes","text":"attributes(hasmeta)\n\nReturns all attributes of meta as a Dict{Symbol, Any}. Needs to be overloaded, and returns empty dict for non overloaded types! Gets overloaded by default for all Meta types.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.diff-Tuple{HyperRectangle, HyperRectangle}","page":"API Reference","title":"GeometryBasics.diff","text":"diff(h1::Rect, h2::Rect)\n\nPerform a difference between two Rects.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.facemeta-Tuple{Mesh}","page":"API Reference","title":"GeometryBasics.facemeta","text":"facemeta(mesh::Mesh; meta_data...)\n\nAttaches metadata to the faces of a mesh\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.getcolumns-Tuple{Any, Vararg{Symbol}}","page":"API Reference","title":"GeometryBasics.getcolumns","text":"getcolumns(t, colnames::Symbol...)\n\nGets a column from any Array like (Table/AbstractArray). For AbstractVectors, a column will be the field names of the element type.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.intersect-Union{Tuple{N}, Tuple{HyperRectangle{N}, HyperRectangle{N}}} where N","page":"API Reference","title":"GeometryBasics.intersect","text":"intersect(h1::Rect, h2::Rect)\n\nPerform a intersection between two Rects.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.mesh-Tuple{Union{AbstractPolygon{Dim, T}, GeometryPrimitive{Dim, T}, AbstractVector{<:AbstractPoint{Dim, T}}, Mesh{Dim, T, Element, V} where {Element<:Polytope{Dim, T}, V<:AbstractVector{Element}}, Tesselation{Dim, T}} where {Dim, T}}","page":"API Reference","title":"GeometryBasics.mesh","text":"mesh(primitive::GeometryPrimitive;\n     pointtype=Point, facetype=GLTriangle,\n     uv=nothing, normaltype=nothing)\n\nCreates a mesh from primitive.\n\nUses the element types from the keyword arguments to create the attributes. The attributes that have their type set to nothing are not added to the mesh. Note, that this can be an Int or Tuple{Int, Int}`, when the primitive is grid based. It also only losely correlates to the number of vertices, depending on the algorithm used. #TODO: find a better number here!\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.mesh-Union{Tuple{AbstractVector{P}}, Tuple{P}} where P<:(AbstractPoint{2})","page":"API Reference","title":"GeometryBasics.mesh","text":"mesh(polygon::AbstractVector{P}; pointtype=P, facetype=GLTriangleFace,\n     normaltype=nothing)\n\nCreate a mesh from a polygon given as a vector of points, using triangulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.orthogonal_vector-Tuple{Any, Any, Any}","page":"API Reference","title":"GeometryBasics.orthogonal_vector","text":"The unnormalized normal of three vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.pop_pointmeta-Tuple{Mesh, Symbol}","page":"API Reference","title":"GeometryBasics.pop_pointmeta","text":"pop_pointmeta(mesh::Mesh, property::Symbol)\n\nRemove property from point metadata. Returns the new mesh, and the property!\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometryBasics.split-Tuple{HyperRectangle, Any, Integer}","page":"API Reference","title":"GeometryBasics.split","text":"split(rectangle, axis, value)\n\nSplits an Rect into two along an axis at a given location.\n\n\n\n\n\n","category":"method"},{"location":"polygons/#Polygons","page":"Polygons","title":"Polygons","text":"","category":"section"},{"location":"primitives/#Primitives","page":"Primitives","title":"Primitives","text":"","category":"section"},{"location":"primitives/#Points-and-Vectors","page":"Primitives","title":"Points and Vectors","text":"","category":"section"},{"location":"primitives/#Simplices","page":"Primitives","title":"Simplices","text":"","category":"section"},{"location":"primitives/#Shapes","page":"Primitives","title":"Shapes","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Circle\nSphere\nCylinder","category":"page"},{"location":"primitives/#Abstract-types","page":"Primitives","title":"Abstract types","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"GeometryPrimitive\nAbstractSimplex\nAbstractMesh","category":"page"},{"location":"decomposition/#Decomposition","page":"Decomposition","title":"Decomposition","text":"","category":"section"},{"location":"decomposition/#GeometryBasics-Mesh-interface","page":"Decomposition","title":"GeometryBasics Mesh interface","text":"","category":"section"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"GeometryBasics defines an interface to decompose abstract geometries into points and triangle meshes. This can be done for any arbitrary primitive, by overloading the following interface:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"\nfunction GeometryBasics.coordinates(rect::Rect2, nvertices=(2,2))\n    mini, maxi = extrema(rect)\n    xrange, yrange = LinRange.(mini, maxi, nvertices)\n    return ivec(((x,y) for x in xrange, y in yrange))\nend\n\nfunction GeometryBasics.faces(rect::Rect2, nvertices=(2, 2))\n    w, h = nvertices\n    idx = LinearIndices(nvertices)\n    quad(i, j) = QuadFace{Int}(idx[i, j], idx[i+1, j], idx[i+1, j+1], idx[i, j+1])\n    return ivec((quad(i, j) for i=1:(w-1), j=1:(h-1)))\nend","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"Those methods, for performance reasons, expect you to return an iterator, to make materializing them with different element types allocation free. But of course, can also return any AbstractArray.","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"With these methods defined, this constructor will magically work:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"rect = Rect2(0.0, 0.0, 1.0, 1.0)\nm = GeometryBasics.mesh(rect)","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"If you want to set the nvertices argument, you need to wrap your primitive in a Tesselation object:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"m = GeometryBasics.mesh(Tesselation(rect, (50, 50)))\nlength(coordinates(m)) == 50^2","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"As you can see, coordinates and faces are also defined on a mesh","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"coordinates(m)\nfaces(m)","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"But will actually not be an iterator anymore. Instead, the mesh constructor uses the decompose function, that will collect the result of coordinates and will convert it to a concrete element type:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"decompose(Point2f, rect) == convert(Vector{Point2f}, collect(coordinates(rect)))","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"The element conversion is handled by simplex_convert, which also handles convert between different face types:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"decompose(QuadFace{Int}, rect) == convert(Vector{QuadFace{Int}}, collect(faces(rect)))\nlength(decompose(QuadFace{Int}, rect)) == 1\nfs = decompose(GLTriangleFace, rect)\nfs isa Vector{GLTriangleFace}\nlength(fs) == 2 # 2 triangles make up one quad ;)","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"mesh uses the most natural element type by default, which you can get with the unqualified Point type:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"decompose(Point, rect) isa Vector{Point{2, Float64}}","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"You can also pass the element type to mesh:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"m = GeometryBasics.mesh(rect, pointtype=Point2f, facetype=QuadFace{Int})","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"You can also set the uv and normal type for the mesh constructor, which will then calculate them for you, with the requested element type:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"m = GeometryBasics.mesh(rect, uv=Vec2f, normaltype=Vec3f)","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"As you can see, the normals are automatically calculated, the same is true for texture coordinates. You can overload this behavior by overloading normals or texturecoordinates the same way as coordinates. decompose works a bit different for normals/texturecoordinates, since they dont have their own element type. Instead, you can use decompose like this:","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"decompose(UV(Vec2f), rect)\ndecompose(Normal(Vec3f), rect)\n# the short form for the above:\ndecompose_uv(rect)\ndecompose_normals(rect)","category":"page"},{"location":"decomposition/","page":"Decomposition","title":"Decomposition","text":"You can also use triangle_mesh, normal_mesh and uv_normal_mesh to call the mesh constructor with predefined element types (Point2/3f, Vec2/3f), and the requested attributes.","category":"page"},{"location":"rectangles/#Rectangles","page":"Rectangles","title":"Rectangles","text":"","category":"section"},{"location":"#GeometryBasics.jl","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"","category":"section"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Basic geometry types.","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"This package aims to offer a standard set of geometry types that easily work with metadata, query frameworks on geometries and different memory layouts. The aim is to create a solid basis for graphics/plotting, finite element analysis, geo applications, and general geometry manipulations - while offering a Julian API that still allows performant C-interop.","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"This package is a replacement for the discontinued GeometryTypes.","category":"page"},{"location":"#Quick-start","page":"GeometryBasics.jl","title":"Quick start","text":"","category":"section"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Create some points:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"using GeometryBasics\n\np1 = Point(3, 1)\np2 = Point(1, 3);\np3 = Point(4, 4);","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Geometries can carry metadata:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"poi = meta(p1, city=\"Abuja\", rainfall=1221.2)","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Metadata is stored in a NamedTuple and can be retrieved as such:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"meta(poi)","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Specific metadata attributes can be directly retrieved:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"poi.rainfall","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"To remove the metadata and keep only the geometry, use metafree:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"metafree(poi)","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Geometries have predefined metatypes:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"multipoi = MultiPointMeta([p1], city=\"Abuja\", rainfall=1221.2)","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Connect the points with lines:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"l1 = Line(p1, p2)\nl2 = Line(p2, p3);","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Connect the lines in a linestring:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"LineString([l1, l2])","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Linestrings can also be constructed directly from points:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"LineString([p1, p2, p3])","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"The same goes for polygons:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Polygon(Point{2, Int}[(3, 1), (4, 4), (2, 4), (1, 2), (3, 1)])","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Create a rectangle placed at the origin with unit width and height:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"rect = Rect(Vec(0.0, 0.0), Vec(1.0, 1.0))","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Decompose the rectangle into two triangular faces:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"rect_faces = decompose(TriangleFace{Int}, rect)","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Decompose the rectangle into four vertices:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"rect_vertices = decompose(Point{2, Float64}, rect)","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Combine the vertices and faces into a triangle mesh:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"mesh = Mesh(rect_vertices, rect_faces)","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"Use GeometryBasics.mesh to get a mesh directly from a geometry:","category":"page"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"mesh = GeometryBasics.mesh(rect)","category":"page"},{"location":"#Aliases","page":"GeometryBasics.jl","title":"Aliases","text":"","category":"section"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":"GeometryBasics exports common aliases for Point, Vec, Mat and Rect:","category":"page"},{"location":"#Vec","page":"GeometryBasics.jl","title":"Vec","text":"","category":"section"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":" T(eltype) Float64 Float32 Int UInt\nN(dim) Vec{N,T} Vecd{N} Vecf{N} Veci{N} Vecui{N}\n2 Vec2{T} Vec2d Vec2f Vec2i Vec2ui\n3 Vec3{T} Vec3d Vec3f Vec3i Vec3ui","category":"page"},{"location":"#Point","page":"GeometryBasics.jl","title":"Point","text":"","category":"section"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":" T(eltype) Float64 Float32 Int UInt\nN(dim) Point{N,T} Pointd{N} Pointf{N} Pointi{N} Pointui{N}\n2 Point2{T} Point2d Point2f Point2i Point2ui\n3 Point3{T} Point3d Point3f Point3i Point3ui","category":"page"},{"location":"#Mat","page":"GeometryBasics.jl","title":"Mat","text":"","category":"section"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":" T(eltype) Float64 Float32 Int UInt\nN(dim) Mat{N,T} Matd{N} Matf{N} Mati{N} Matui{N}\n2 Mat2{T} Mat2d Mat2f Mat2i Mat2ui\n3 Mat3{T} Mat3d Mat3f Mat3i Mat3ui","category":"page"},{"location":"#Rect","page":"GeometryBasics.jl","title":"Rect","text":"","category":"section"},{"location":"","page":"GeometryBasics.jl","title":"GeometryBasics.jl","text":" T(eltype) Float64 Float32 Int UInt\nN(dim) Rect{N,T} Rectd{N} Rectf{N} Recti{N} Rectui{N}\n2 Rect2{T} Rect2d Rect2f Rect2i Rect2ui\n3 Rect3{T} Rect3d Rect3f Rect3i Rect3ui","category":"page"},{"location":"implementation/#Implementation","page":"Implementation","title":"Implementation","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"In the backend, GeometryTypes relies on fixed-size arrays, specifically static vectors.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"TODO add more here.","category":"page"},{"location":"meshes/#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"meshes/#Types","page":"Meshes","title":"Types","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"AbstractMesh\nMesh","category":"page"},{"location":"meshes/#How-to-create-a-mesh","page":"Meshes","title":"How to create a mesh","text":"","category":"section"},{"location":"meshes/#Meshing.jl","page":"Meshes","title":"Meshing.jl","text":"","category":"section"},{"location":"meshes/#MeshIO.jl","page":"Meshes","title":"MeshIO.jl","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"The MeshIO.jl package provides load/save support for several file formats which store meshes.","category":"page"},{"location":"meshes/#How-to-access-data","page":"Meshes","title":"How to access data","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"The following functions can be called on an AbstractMesh to access its underlying data.","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"faces\ncoordinates\ntexturecoordinates\nnormals","category":"page"}]
}
