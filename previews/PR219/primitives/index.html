<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Primitives · GeometryBasics.jl</title><meta name="title" content="Primitives · GeometryBasics.jl"/><meta property="og:title" content="Primitives · GeometryBasics.jl"/><meta property="twitter:title" content="Primitives · GeometryBasics.jl"/><meta name="description" content="Documentation for GeometryBasics.jl."/><meta property="og:description" content="Documentation for GeometryBasics.jl."/><meta property="twitter:description" content="Documentation for GeometryBasics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GeometryBasics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">GeometryBasics.jl</a></li><li class="is-active"><a class="tocitem" href>Primitives</a><ul class="internal"><li><a class="tocitem" href="#Existing-GeometryPrimitives"><span>Existing GeometryPrimitives</span></a></li><li><a class="tocitem" href="#Tesselation"><span>Tesselation</span></a></li><li><a class="tocitem" href="#Primitive-Interface-/-Implementing-a-new-GeometryPrimitive"><span>Primitive Interface / Implementing a new GeometryPrimitive</span></a></li></ul></li><li><a class="tocitem" href="../polygons/">Polygons</a></li><li><a class="tocitem" href="../meshes/">Meshes</a></li><li><a class="tocitem" href="../decomposition/">Decomposition</a></li><li><a class="tocitem" href="../static_array_types/">Point, Vec and Mat</a></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Primitives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Primitives</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/GeometryBasics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/GeometryBasics.jl/blob/master/docs/src/primitives.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Primitives"><a class="docs-heading-anchor" href="#Primitives">Primitives</a><a id="Primitives-1"></a><a class="docs-heading-anchor-permalink" href="#Primitives" title="Permalink"></a></h1><p>In GeometryBasics.jl, a <code>GeometryPrimitive</code> is an object from which a mesh can be constructed.</p><h2 id="Existing-GeometryPrimitives"><a class="docs-heading-anchor" href="#Existing-GeometryPrimitives">Existing GeometryPrimitives</a><a id="Existing-GeometryPrimitives-1"></a><a class="docs-heading-anchor-permalink" href="#Existing-GeometryPrimitives" title="Permalink"></a></h2><p>GeometryBasics comes with a few predefined primitives:</p><h4 id="HyperRectangle"><a class="docs-heading-anchor" href="#HyperRectangle">HyperRectangle</a><a id="HyperRectangle-1"></a><a class="docs-heading-anchor-permalink" href="#HyperRectangle" title="Permalink"></a></h4><p>A <code>Rect{D, T} = HyperRectangle{D, T}</code> is a D-dimensional axis-aligned  hyperrectangle defined by an origin and a size.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using GeometryBasics</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; r1 = HyperRectangle{4, Float64}(Point{4, Float64}(0), Vec{4, Float64}(1))</code><code class="nohighlight hljs ansi" style="display:block;">Rectd{4}([0.0, 0.0, 0.0, 0.0], [1.0, 1.0, 1.0, 1.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; r2 = Rect3f(Point3f(-1), Vec3f(2))</code><code class="nohighlight hljs ansi" style="display:block;">HyperRectangle{3, Float32}(Float32[-1.0, -1.0, -1.0], Float32[2.0, 2.0, 2.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; r3 = Rect2i(0, 0, 1, 1)</code><code class="nohighlight hljs ansi" style="display:block;">HyperRectangle{2, Int64}([0, 0], [1, 1])</code></pre><p>Rect2 supports normal and texture coordinate generation as well as tesselation. Without tesselation, the coordinates of 2D Rects are defined in anti-clockwise order. Rect3 supports normals and texture coordinates, but not tesselation.</p><p>Shorthands:</p><table><tr><th style="text-align: right"></th><th style="text-align: right"><code>T</code>(eltype)</th><th style="text-align: right"><code>Float64</code></th><th style="text-align: right"><code>Float32</code></th><th style="text-align: right"><code>Int</code></th><th style="text-align: right"><code>UInt</code></th></tr><tr><td style="text-align: right"><code>N</code>(dim)</td><td style="text-align: right"><code>Rect{N,T}</code></td><td style="text-align: right"><code>Rectd{N}</code></td><td style="text-align: right"><code>Rectf{N}</code></td><td style="text-align: right"><code>Recti{N}</code></td><td style="text-align: right"><code>Rectui{N}</code></td></tr><tr><td style="text-align: right"><code>2</code></td><td style="text-align: right"><code>Rect2{T}</code></td><td style="text-align: right"><code>Rect2d</code></td><td style="text-align: right"><code>Rect2f</code></td><td style="text-align: right"><code>Rect2i</code></td><td style="text-align: right"><code>Rect2ui</code></td></tr><tr><td style="text-align: right"><code>3</code></td><td style="text-align: right"><code>Rect3{T}</code></td><td style="text-align: right"><code>Rect3d</code></td><td style="text-align: right"><code>Rect3f</code></td><td style="text-align: right"><code>Rect3i</code></td><td style="text-align: right"><code>Rect3ui</code></td></tr></table><h4 id="Sphere-and-Circle"><a class="docs-heading-anchor" href="#Sphere-and-Circle">Sphere and Circle</a><a id="Sphere-and-Circle-1"></a><a class="docs-heading-anchor-permalink" href="#Sphere-and-Circle" title="Permalink"></a></h4><p><code>Circle</code> and <code>Sphere</code> are the 2 and 3 dimensional variants of <code>HyperSphere</code>.  They are defined by an origin and a radius. While you can technically create a HyperSphere of any dimension, decomposition is only defined in 2D and 3D.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s1 = HyperSphere{4, Int}(Point{4, Int}(0), 5)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: HyperSphere not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s2 = Sphere(Point3f(0, 0, 1), 1)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: Point3f not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s3 = Circle(Point2d(0), 2.0)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: Point2d not defined</code></pre><p>Circle and Sphere support normal and texture coordinate generation as well as tesselation. The coordinates of Circle are defined in anti-clockwise order.</p><h4 id="Cylinder"><a class="docs-heading-anchor" href="#Cylinder">Cylinder</a><a id="Cylinder-1"></a><a class="docs-heading-anchor-permalink" href="#Cylinder" title="Permalink"></a></h4><p>A <code>Cylinder</code> is a 3D shape defined by two points and a radius.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = Cylinder(Point3f(-1, 0, 0), Point3f(0, 0, 1), 0.3f0) # start point, end point, radius</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: Point3f not defined</code></pre><p>Cylinder supports normals an Tesselation, but currently no texture coordinates.</p><h4 id="Pyramid"><a class="docs-heading-anchor" href="#Pyramid">Pyramid</a><a id="Pyramid-1"></a><a class="docs-heading-anchor-permalink" href="#Pyramid" title="Permalink"></a></h4><p><code>Pyramid</code> corresponds to a pyramid shape with a square base and four triangles coming together into a sharp point. It is defined by by the center point of the base, its height and its width.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = Pyramid(Point3f(0), 1f0, 0.3f0) # center, height, width</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: Point3f not defined</code></pre><p>Pyramid supports normals, but currently no texture coordinates or tesselation</p><h2 id="Tesselation"><a class="docs-heading-anchor" href="#Tesselation">Tesselation</a><a id="Tesselation-1"></a><a class="docs-heading-anchor-permalink" href="#Tesselation" title="Permalink"></a></h2><p>In GeometryBasics <code>Tesselation</code> is a wrapper type for primitives which communicates how dense the mesh generated from one should be.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = Tesselation(Cylinder(Point3f(0), Point3f(0,0,1), 0.2), 32) # 32 vertices for each circle</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: Point3f not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; normal_mesh(t)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: normal_mesh not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = Tesselation(Rect2(Point2f(0), Vec2f(1)), (8, 6)) # 8 vertices in x direction by 6 in y direction</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: Point2f not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; triangle_mesh(t)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: triangle_mesh not defined</code></pre><h2 id="Primitive-Interface-/-Implementing-a-new-GeometryPrimitive"><a class="docs-heading-anchor" href="#Primitive-Interface-/-Implementing-a-new-GeometryPrimitive">Primitive Interface / Implementing a new GeometryPrimitive</a><a id="Primitive-Interface-/-Implementing-a-new-GeometryPrimitive-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-Interface-/-Implementing-a-new-GeometryPrimitive" title="Permalink"></a></h2><p>Every primitive should inherit from <code>GeometryPrimitive{Dim, eltype}</code> and implement at least <code>coordinates(primitive)</code> and <code>faces(primitive)</code> so that a mesh can be build from it. This will also be enough to automatically generate normals for a 3D primitive and texture coordinates for a 2D primitive. You can also implement functions to generate them directly with <code>normals(primitive)</code> and <code>texturecoordinates(primitive)</code>. Depending on your primitive this might be necessary to get the normals and uvs you want.</p><p>To be compatible with <code>Tesselation</code> all of the functions mentioned above should implement a second tesselation argument. This will be the second argument passed to the Tesselation constructor. It&#39;s up to you to decide what makes sense here, though typically it&#39;s just an integer that more or less corresponds to the number of generated vertices.</p><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><p>As an example, let&#39;s implement a parallelepiped, i.e. a 3D version or a parallelogram. In this case we need an origin and 3 vectors telling us how far and in which directions the object extends.</p><pre><code class="language-julia hljs">struct Parallelepiped{T} &lt;: GeometryPrimitive{3, T}
    origin::Point{3, T}
    v1::Vec{3, T}
    v2::Vec{3, T}
    v3::Vec{3, T}
end</code></pre><p>Like the <code>Rect{3}</code>, this object comes with 8 unique positions which we want to return as its <code>coordinates</code>.</p><pre><code class="language-julia hljs">function GeometryBasics.coordinates(primitive::Parallelepiped{T}) where {T}
    o = primitive.origin
    v1 = primitive.v1; v2 = primitive.v2; v3 = primitive.v3
    return Point{3, T}[o, o+v2, o+v1+v2, o+v1,  o+v3, o+v2+v3, o+v1+v2+v3, o+v1+v3]
end</code></pre><p>To connect these points into a mesh, we need to generate a set of faces. The faces of a prallelepiped are parallelograms, which we can describe with <code>QuadFace</code>.  Here we should be concious of the winding direction of faces. They are often used to determine the front vs the backside of a (2D) face. For example GeometryBasics normal generation and OpenGL&#39;s backface culling assume a counter-clockwise windig direction to correspond to a front-facing face. This means that if we look at a face from outside the shape, the positions referred to by that face should be ordered counter-clockwise. With that in mind the faces of our primitive become:</p><pre><code class="language-julia hljs">function GeometryBasics.faces(::Parallelepiped)
    return QuadFace{Int}[
        (1, 2, 3, 4), (5, 8, 7, 6), # facing -n3, +n3 (n3 being the normal of v1 x v2)
        (1, 5, 6, 2), (4, 3, 7, 8), # facing -n2, +n2
        (2, 6, 7, 3), (1, 4, 8, 5), # facing -n1, +n1
    ]
end</code></pre><p>Note that you can check the correct winding direction fairly easily with Makie and the default generated normals. After implementing faces and coordinates, you can create a mesh plot of your primitive with <code>Makie.mesh(primitive)</code>. If the mesh reacts to light in a reasonable way, i.e. gets brighter when light shines on it, then your faces have the correct winding direction. (It maybe useful to compare to other primitives like <code>Sphere(Point3f(0), 1f0)</code> here.)</p><p>Next on our TODO list are normals. The default normals produced by <code>GeometryBasics.normal(primitive)</code> are vertex normals, which assume that a primitive to be smooth. Since this is not the case for our primitive, we need to implement custom normals. Here we could rely on <code>GeometryBasics.face_normal()</code> which returns a normal per face, but for this example we will implement them ourselves.</p><p>For our shape we want one normal per face, pointing in the normal direction of the corresponding 2D plane. We can calculate the normal vector as <code>n = normalize(cross(v, w))</code> where v and w correspond to combinations of v1, v2 and v3. To get them to act per face rather than per vertex, we need to overwrite the faces generated by <code>faces()</code>. We can do that by creating a <code>FaceView</code> with a new set of faces which only act on normals. Each of these new faces needs to refer to one normal by index to get what we want.</p><pre><code class="language-julia hljs">using LinearAlgebra
function GeometryBasics.normals(primitive::Parallelepiped)
    n1 = normalize(cross(primitive.v2, primitive.v3))
    n2 = normalize(cross(primitive.v3, primitive.v1))
    n3 = normalize(cross(primitive.v1, primitive.v2))
    ns = [-n3, n3, -n2, n2, -n1, n1]
    fs = QuadFace{Int}[1, 2, 3, 4, 5, 6] # = [QuadFace{Int}(1), QuadFace{Int}(2), ...]
    return FaceView(ns, fs)
end</code></pre><p>As the last piece of the interface we can implement texture coordinates. They generally refer to a 2D image with normalized 2D coordinates on a per-vertex basis. There are many ways to define these coordinates. Here we will partition the image in 2x3 even sized rectangular sections, split by the sign of the normal directions defined above.</p><pre><code class="language-julia hljs">function GeometryBasics.texturecoordinates(::Parallelepiped{T}) where {T}
    uvs = [Vec2f(x, y) for x in range(0, 1, length=4) for y in range(0, 1, 3)]
    fs = QuadFace{Int}[
        (1, 2, 5, 4),   (2, 3, 6, 5),
        (4, 5, 8, 7),   (5, 6, 9, 8), 
        (7, 8, 11, 10), (8, 9, 12, 11)
    ]
    return FaceView(uvs, fs)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« GeometryBasics.jl</a><a class="docs-footer-nextpage" href="../polygons/">Polygons »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 19 September 2024 16:18">Thursday 19 September 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
