<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Meshes · GeometryBasics.jl</title><meta name="title" content="Meshes · GeometryBasics.jl"/><meta property="og:title" content="Meshes · GeometryBasics.jl"/><meta property="twitter:title" content="Meshes · GeometryBasics.jl"/><meta name="description" content="Documentation for GeometryBasics.jl."/><meta property="og:description" content="Documentation for GeometryBasics.jl."/><meta property="twitter:description" content="Documentation for GeometryBasics.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">GeometryBasics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">GeometryBasics.jl</a></li><li><a class="tocitem" href="primitives.html">Primitives</a></li><li><a class="tocitem" href="polygons.html">Polygons</a></li><li class="is-active"><a class="tocitem" href="meshes.html">Meshes</a><ul class="internal"><li><a class="tocitem" href="#Mesh"><span>Mesh</span></a></li><li><a class="tocitem" href="#MetaMesh"><span>MetaMesh</span></a></li><li><a class="tocitem" href="#How-to-create-a-mesh"><span>How to create a mesh</span></a></li></ul></li><li><a class="tocitem" href="decomposition.html">Decomposition</a></li><li><a class="tocitem" href="boundingboxes.html">Bounding Boxes</a></li><li><a class="tocitem" href="static_array_types.html">Point, Vec and Mat</a></li><li><a class="tocitem" href="api.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="meshes.html">Meshes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="meshes.html">Meshes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/GeometryBasics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/GeometryBasics.jl/blob/master/docs/src/meshes.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h1><p>GeometryBasics defines two mesh types to work with - <code>Mesh</code> and <code>MetaMesh</code></p><h2 id="Mesh"><a class="docs-heading-anchor" href="#Mesh">Mesh</a><a id="Mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryBasics.Mesh-meshes" href="#GeometryBasics.Mesh-meshes"><code>GeometryBasics.Mesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Mesh{PositionDim, PositionType, FaceType, VertexAttributeNames, VertexAttributeTypes, FaceVectorType} &lt;: AbstractMesh{PositionDim, PositionType} &lt;: AbstractGeometry{PositionDim, PositionType}</code></pre><p>The type of a concrete mesh. The associated struct contains 3 fields:</p><pre><code class="language-julia hljs">struct Mesh{...}
    vertex_attributes::NamedTuple{VertexAttributeNames, VertexAttributeTypes}
    faces::FaceVectorType
    views::Vector{UnitRange{Int}}
end</code></pre><p>A vertex typically carries multiple distinct pieces of data, e.g. a position, a normal, a texture coordinate, etc. We call those pieces of data vertex attributes. The <code>vertex_attributes</code> field contains the name and a collection <code>&lt;: AbstractVector</code> or <code>&lt;: FaceView</code> for each attribute. The n-th element of that collection is the value of the corresponding attribute for the n-th vertex.</p><pre><code class="language-julia hljs">#                   vertex       1        2        3
vertex_attributes[:position] = [pos1,    pos2,    pos3,    ...]
vertex_attributes[:normal]   = [normal1, normal2, normal3, ...]
...</code></pre><p>A <code>NamedTuple</code> is used here to allow different meshes to carry different vertex attributes while also keeping things type stable. The constructor enforces a few restrictions:</p><ul><li>The first attribute must be named <code>position</code> and must have a <code>Point{PositionDim, PositionType}</code> eltype.</li><li>Each vertex attribute must refer to the same number of vertices. (All vertex attributes defined by</li></ul><p>AbstractVector must match in length. For FaceViews, the number of faces needs to match.)</p><p>See also: <a href="api.html#GeometryBasics.vertex_attributes-Tuple{Mesh}"><code>vertex_attributes</code></a>, <a href="api.html#GeometryBasics.coordinates-Tuple{AbstractVector{&lt;:Point}}"><code>coordinates</code></a>, <a href="api.html#GeometryBasics.normals"><code>normals</code></a>, <a href="api.html#GeometryBasics.texturecoordinates"><code>texturecoordinates</code></a>, <a href="api.html#GeometryBasics.decompose-Union{Tuple{F}, Tuple{Type{F}, AbstractGeometry}} where F&lt;:AbstractFace"><code>decompose</code></a>, <a href="meshes.html#FaceView"><code>FaceView</code></a>, <a href="api.html#GeometryBasics.expand_faceviews-Tuple{Mesh}"><code>expand_faceviews</code></a></p><p>The <code>faces</code> field is a collection <code>&lt;: AbstractVector{FaceType}</code> containing faces that describe how vertices are connected. Typically these are <code>(GL)TriangleFace</code>s or <code>QuadFace</code>s, but they can be any collection of vertex indices <code>&lt;: AbstractFace</code>.</p><p>See also: <a href="api.html#GeometryBasics.faces-Tuple{AbstractVector{&lt;:AbstractFace}}"><code>faces</code></a>, <a href="api.html#GeometryBasics.decompose-Union{Tuple{F}, Tuple{Type{F}, AbstractGeometry}} where F&lt;:AbstractFace"><code>decompose</code></a></p><p>The <code>views</code> field can be used to separate the mesh into mutliple submeshes. Each submesh is described by a &quot;view&quot; into the <code>faces</code> vector, i.e. submesh n uses <code>mesh.faces[mesh.views[n]]</code>. A <code>Mesh</code> can be constructed without <code>views</code>, which results in an empty <code>views</code> vector.</p><p>See also: <a href="api.html#Base.merge-Tuple{AbstractVector{&lt;:Mesh}}"><code>merge</code></a>, <a href="api.html#GeometryBasics.split_mesh"><code>split_mesh</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/GeometryBasics.jl/blob/1ce2a812f66f7486ec66e5d4d461f61d74f627f2/src/basic_types.jl#L454-L503">source</a></section></article><p>You can get data from a mesh using a few interface functions:</p><ul><li><code>vertex_attributes(mesh) = mesh.vertex_attributes</code></li><li><code>coordinates(mesh) = mesh.vertex_attributes[:position]</code></li><li><code>normals(mesh) = mesh.vertex_attributes[:normal]</code></li><li><code>texturecoordinates(mesh) = mesh.vertex_attributes[:uv]</code></li><li><code>faces(mesh) = mesh.faces</code></li></ul><p>You can also grab the contents of <code>mesh.vertex_attributes</code> as if they were fields of the <code>Mesh</code>, e.g. <code>mesh.position</code> works.</p><h3 id="Custom-Attributes"><a class="docs-heading-anchor" href="#Custom-Attributes">Custom Attributes</a><a id="Custom-Attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Attributes" title="Permalink"></a></h3><p>Meshes support arbitrary custom attributes beyond the standard position, normal, and UV coordinates. You can attach per-vertex or per-face data like material properties, identifiers, or computed values. These are stored in <code>mesh.vertex_attributes</code> and accessed using the same interface.</p><pre><code class="language-julia hljs">using GeometryBasics

# Define custom data type
struct Material
    emissivity::Float64
    absorptivity::Float64
    reflectivity::Float64
end

# Create mesh with custom attributes
points = [Point3f(0,0,0), Point3f(1,0,0), Point3f(0,1,0), Point3f(0,0,1)]
faces = [TriangleFace(1,2,3), TriangleFace(1,2,4), TriangleFace(1,3,4), TriangleFace(2,3,4)]

materials = [
    Material(0.1, 0.8, 0.1),
    Material(0.2, 0.7, 0.1),
    Material(0.0, 0.9, 0.1),
    Material(0.3, 0.6, 0.1)
]

face_names = [&quot;bottom&quot;, &quot;side1&quot;, &quot;side2&quot;, &quot;top&quot;]

# Use per_face to create FaceViews for per-face attributes
mesh = GeometryBasics.mesh(
    points,
    faces,
    material=per_face(materials, faces),
    face_name=per_face(face_names, faces)
)

# Access custom attributes
mesh.material[2]  # Get material of second face
mesh.face_name[1]  # Get name of first face</code></pre><p>This pattern is useful for physical simulations, rendering with material properties, or tagging mesh regions for analysis.</p><h3 id="FaceView"><a class="docs-heading-anchor" href="#FaceView">FaceView</a><a id="FaceView-1"></a><a class="docs-heading-anchor-permalink" href="#FaceView" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryBasics.FaceView-meshes" href="#GeometryBasics.FaceView-meshes"><code>GeometryBasics.FaceView</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FaceView(data, faces)</code></pre><p>A FaceView is an alternative to passing a vertex attribute directly to a mesh. It bundles <code>data</code> with a new set of <code>faces</code> which may index that data differently from the faces defined in a mesh. This can be useful to avoid duplication in <code>data</code>.</p><p>For example, <code>data</code> can be defined per face by giving each face just one (repeated) index:</p><pre><code class="language-julia hljs">per_face_normals = FaceView(
    normals,                 # one per face
    FT.(eachindex(normals))  # with FT = facetype(mesh)
)</code></pre><p>If you need a mesh with strictly per-vertex data, e.g. for rendering, you can use <code>expand_faceviews(mesh)</code> to convert every vertex attribute to be per-vertex. This will duplicate data and reorder faces as needed.</p><p>You can get the data of a FaceView with <code>values(faceview)</code> and the faces with <code>faces(faceview)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/GeometryBasics.jl/blob/1ce2a812f66f7486ec66e5d4d461f61d74f627f2/src/basic_types.jl#L341-L363">source</a></section></article><p>The purpose of FaceView is to allow you to add data that doesn&#39;t use the same vertex indices as <code>mesh.faces</code> As a minimal example consider a mesh that is just one triangle, i.e. 3 position and one triangle face <code>TriangleFace(1,2,3)</code>. Let&#39;s say we want to add a flat color to the triangle. In this case we only have one color, but our face refers to 3 different vertices (3 different positions). To avoid duplicating the color data, we can instead define a new triangle face <code>TriangleFace(1)</code> and add the color attribute as a <code>FaceView([color], [TriangleFace(1)])</code>. If we ever need the mesh to be defined with just one common set of faces, i.e. no FaceView and appropriately duplicated vertex data, we can use <code>expand_faceviews(mesh)</code> to generate it.</p><p>On a larger scale this can be useful for memory and performance reason, e.g. when you do calculations with vertex attributes. It can also simplify some definitions, like for example <code>Rect3</code>. In that case we have 8 positions and 6 normals with FaceViews, or 24 without (assuming per-face normals).</p><p>For the relatively common case of per-face data, you can use the <code>per_face</code> convenience function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryBasics.per_face" href="#GeometryBasics.per_face"><code>GeometryBasics.per_face</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">per_face(data, faces)
per_face(data, mesh)</code></pre><p>Generates a <code>FaceView</code> that applies the given data per face, rather than per vertex. The result can then be used to create a (new) mesh:</p><pre><code class="nohighlight hljs">mesh(..., attribute_name = per_face(data, faces))
mesh(old_mesh, attribute_name = per_face(data, old_mesh))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/GeometryBasics.jl/blob/1ce2a812f66f7486ec66e5d4d461f61d74f627f2/src/meshes.jl#L589-L599">source</a></section></article><h2 id="MetaMesh"><a class="docs-heading-anchor" href="#MetaMesh">MetaMesh</a><a id="MetaMesh-1"></a><a class="docs-heading-anchor-permalink" href="#MetaMesh" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryBasics.MetaMesh-meshes" href="#GeometryBasics.MetaMesh-meshes"><code>GeometryBasics.MetaMesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MetaMesh(mesh; metadata...)
MetaMesh(positions, faces; metadata...)</code></pre><p>Constructs a MetaMesh either from another <code>mesh</code> or by constructing another mesh with the given <code>positions</code> and <code>faces</code>. Any keyword arguments given will be stored in the <code>meta</code> field in <code>MetaMesh</code>.</p><p>This struct is meant to be used for storage of non-vertex data. Any vertex related data should be stored as a vertex attribute in <code>Mesh</code>. One example of such data is material data, which is defined per view in <code>mesh.views</code>, i.e. per submesh.</p><p>The metadata added to the MetaMesh can be manipulated with Dict-like operations (getindex, setindex!, get, delete, keys, etc). Vertex attributes can be accessed via fields and the same getters as mesh. The mesh itself can be retrieved with <code>Mesh(metamesh)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/GeometryBasics.jl/blob/1ce2a812f66f7486ec66e5d4d461f61d74f627f2/src/basic_types.jl#L742-L758">source</a></section></article><p><code>MetaMesh</code> wraps a <code>Mesh</code> and allows you to attach global metadata that applies to the entire mesh rather than individual vertices or faces. This is useful for storing information like source file paths, transformation matrices, object identifiers, or simulation parameters.</p><pre><code class="language-julia hljs">using GeometryBasics

# Create a basic mesh
points = [Point3f(0,0,0), Point3f(1,0,0), Point3f(0,1,0)]
faces = [TriangleFace(1,2,3)]
mesh = GeometryBasics.mesh(points, faces; attribute=rand(3))

# Wrap with MetaMesh and add global metadata
meta_mesh = MetaMesh(mesh, source_file=&quot;model.obj&quot;, object_id=42, scale=1.5)

# Access metadata
meta_mesh[:source_file] # &quot;model.obj&quot;
meta_mesh[:object_id] # 42
meta_mesh.attribute # access vertex attributes via getproperty
# The underlying mesh is still accessible
meta_mesh.mesh</code></pre><p>You can combine <code>MetaMesh</code> for global properties with per-face/per-vertex attributes for complete geometric and metadata representation:</p><pre><code class="language-julia hljs"># Create mesh with both per-face attributes and global metadata
mesh = GeometryBasics.mesh(
    points, faces,
    material=per_face(materials, faces),
    normal=face_normals(points, faces)
)

meta_mesh = MetaMesh(mesh, gltf_file=&quot;spacecraft.gltf&quot;, mass=150.0)</code></pre><h2 id="How-to-create-a-mesh"><a class="docs-heading-anchor" href="#How-to-create-a-mesh">How to create a mesh</a><a id="How-to-create-a-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-create-a-mesh" title="Permalink"></a></h2><h3 id="GeometryBasics"><a class="docs-heading-anchor" href="#GeometryBasics">GeometryBasics</a><a id="GeometryBasics-1"></a><a class="docs-heading-anchor-permalink" href="#GeometryBasics" title="Permalink"></a></h3><p>In GeometryBasics you mainly create meshes from primitives using a few constructors:</p><ul><li><code>triangle_mesh(primitive)</code> generates the most basic mesh (i.e. positions and faces)</li><li><code>normal_mesh(primitive)</code> generates a mesh with normals (generated if the primitive doesn&#39;t implement <code>normal()</code>)</li><li><code>uv_mesh(primitive)</code> generates a mesh with texture coordinates (generated if the primitive doesn&#39;t implement <code>texturecoordinates()</code>)</li><li><code>uv_normal_mesh(primitive)</code> generates a mesh with normals and texture coordinates</li></ul><p>Each of these constructors also includes keyword arguments for setting types, i.e. <code>pointtype</code>, <code>facetype</code>, <code>normaltype</code> and <code>uvtype</code> as appropriate. Of course you can also construct a mesh directly from data, either with there various <code>Mesh()</code> or <code>GeometryBasics.mesh()</code> constructors. The latter also include a <code>pointtype</code> and <code>facetype</code> conversion.</p><p>Finally there is also a <code>merge(::Vector{Mesh})</code> function which combines multiple meshes into a single one. Note that this doesn&#39;t remove any data (e.g. hidden or duplicate vertices), and may remove <code>FaceView</code>s if they are incompatible between meshes.</p><h3 id="Meshing.jl"><a class="docs-heading-anchor" href="#Meshing.jl">Meshing.jl</a><a id="Meshing.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Meshing.jl" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Meshing
using GeometryBasics
using WGLMakie
using LinearAlgebra

gyroid(v) = cos(v[1])*sin(v[2])+cos(v[2])*sin(v[3])+cos(v[3])*sin(v[1])
gyroid_shell(v) = max(gyroid(v)-0.4,-gyroid(v)-0.4)
xr,yr,zr = ntuple(_-&gt;LinRange(0,pi*4,50),3)

A = [gyroid_shell((x,y,z)) for x in xr, y in yr, z in zr]
# generate directly using GeometryBasics API
# Rect specifies the sampling intervals
vts, fcs = isosurface(A, MarchingCubes())
# view with Makie
fcs = TriangleFace{Int}.(fcs)
vts = Point3d.(vts)
Makie.mesh(GeometryBasics.Mesh(vts, fcs), color=[norm(v) for v in vts])</code></pre><div>
  <div class="bonito-fragment" id="9b16bd6e-315f-48e8-a77f-3772f8c92870" data-jscall-id="root">
    <div>
      <script src="bonito/js/Bonito.bundled13389133706764782584.js" type="module"></script>
      <style></style>
    </div>
    <div>
      <script type="module">Bonito.init_session("9b16bd6e-315f-48e8-a77f-3772f8c92870", null, "root", false);
</script>
      <span></span>
    </div>
  </div>
  <div class="bonito-fragment" id="276b6530-049b-4a5d-902a-b41804a1e085" data-jscall-id="subsession-application-dom">
    <div>
      <style></style>
    </div>
    <div>
      <script type="module">Bonito.init_session("276b6530-049b-4a5d-902a-b41804a1e085", Bonito.fetch_binary('bonito/bin/977ad3b1674f4cb2faafd3fa57edd6bfaacfd28f-10171729885694690045.bin'), "sub", false);
</script>
      <div style="width: 100%; height: 100%" data-jscall-id="1">
        <canvas data-jp-suppress-context-menu style="display: block" data-jscall-id="2" data-lm-suppress-shortcuts="true" tabindex="0"></canvas>
      </div>
    </div>
  </div>
</div><h3 id="MeshIO.jl"><a class="docs-heading-anchor" href="#MeshIO.jl">MeshIO.jl</a><a id="MeshIO.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MeshIO.jl" title="Permalink"></a></h3><p>The <a href="https://github.com/JuliaIO/MeshIO.jl"><code>MeshIO.jl</code></a> package provides load/save support for several file formats which store meshes.</p><pre><code class="language-julia hljs">using WGLMakie, GeometryBasics

m = Makie.loadasset(&quot;cat.obj&quot;)
Makie.mesh(m; color=Makie.loadasset(&quot;diffusemap.png&quot;), axis=(; show_axis=false))</code></pre><div class="bonito-fragment" id="21000dac-1a79-44d3-b376-ed9a1b4285ff" data-jscall-id="subsession-application-dom">
  <div>
    <style></style>
  </div>
  <div>
    <script type="module">Bonito.init_session("21000dac-1a79-44d3-b376-ed9a1b4285ff", Bonito.fetch_binary('bonito/bin/abd0ffcd6ec0a42e0a26e47e4e0095579953c031-3771484937662930297.bin'), "sub", false);
</script>
    <div style="width: 100%; height: 100%" data-jscall-id="3">
      <canvas data-jp-suppress-context-menu style="display: block" data-jscall-id="4" data-lm-suppress-shortcuts="true" tabindex="0"></canvas>
    </div>
  </div>
</div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="polygons.html">« Polygons</a><a class="docs-footer-nextpage" href="decomposition.html">Decomposition »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 30 September 2025 19:14">Tuesday 30 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
